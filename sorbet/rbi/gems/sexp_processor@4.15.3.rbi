# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sexp_processor` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

class MethodBasedSexpProcessor < ::SexpProcessor
  def initialize; end

  def class_stack; end
  def in_klass(name); end
  def in_method(name, file, line, line_max = T.unsafe(nil)); end
  def in_sklass; end
  def klass_name; end
  def method_locations; end
  def method_name; end
  def method_stack; end
  def process_class(exp); end
  def process_defn(exp); end
  def process_defs(exp); end
  def process_module(exp); end
  def process_sclass(exp); end
  def process_until_empty(exp); end
  def sclass; end
  def signature; end
  def with_new_method_stack; end
end

class NotEmptyError < ::SexpProcessorError; end

class Object < ::BasicObject
  include ::ActiveSupport::Dependencies::Loadable
  include ::ActiveSupport::ForkTracker::CoreExt
  include ::ActiveSupport::ForkTracker::CoreExtPrivate
  include ::Kernel
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::ActiveSupport::Tryable
  include ::PP::ObjectMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder

  def deep_clone; end

  private

  def s(*args, &blk); end
end

class Sexp < ::Array
  def initialize(*args); end

  def +(o); end
  def /(pattern); end
  def ==(obj); end
  def =~(pattern); end
  def [](a); end
  def add(_arg0); end
  def add_all(x); end
  def all_structural_subhashes; end
  def array_type?; end
  def block_pass?; end
  def check_line_numbers; end
  def code_index; end
  def comments; end
  def comments=(_arg0); end
  def compact; end
  def deep_each(&block); end
  def depth; end
  def each_of_type(t, &b); end
  def each_sexp; end
  def eql?(o); end
  def file; end
  def file=(_arg0); end
  def find_and_replace_all(from, to); end
  def find_node(name, delete = T.unsafe(nil)); end
  def find_nodes(name); end
  def gsub(pattern, repl); end
  def has_code?; end
  def hash; end
  def head; end
  def inspect; end
  def line(n = T.unsafe(nil)); end
  def line=(_arg0); end
  def line_max; end
  def line_min; end
  def map(&blk); end
  def mass; end
  def method_missing(meth, delete = T.unsafe(nil)); end
  def modified; end
  def modified=(_arg0); end
  def modified?; end
  def new(*body); end
  def nil_line?; end
  def node_type; end
  def paren; end
  def paren=(_arg0); end
  def pretty_print(q); end
  def pure_ruby_hash; end
  def replace_sexp(pattern, &block); end
  def respond_to?(msg, private = T.unsafe(nil)); end
  def rest(from = T.unsafe(nil)); end
  def satisfy?(pattern); end
  def search_each(pattern, &block); end
  def sexp_body(from = T.unsafe(nil)); end
  def sexp_body=(v); end
  def sexp_type; end
  def sexp_type=(v); end
  def split_at(n); end
  def split_code; end
  def structural_hash; end
  def structure; end
  def sub(pattern, repl); end
  def to_a; end
  def to_s; end
  def to_sym; end
  def value; end
  def values(from = T.unsafe(nil)); end

  private

  def initialize_copy(o); end

  class << self
    def -(arg); end
    def _; end
    def ___; end
    def all(*args); end
    def any(*args); end
    def atom; end
    def child(child); end
    def from_array(a); end
    def include(child); end
    def k(klass); end
    def m(*values); end
    def not?(arg); end
    def q(*args); end
    def s(*args); end
    def t(name); end
  end
end

class Sexp::All < ::Sexp::Matcher
  def initialize(*options); end

  def ==(o); end
  def inspect; end
  def options; end
  def pretty_print(q); end
  def satisfy?(o); end
end

class Sexp::Any < ::Sexp::Matcher
  def initialize(*options); end

  def ==(o); end
  def inspect; end
  def options; end
  def pretty_print(q); end
  def satisfy?(o); end
end

class Sexp::Atom < ::Sexp::Matcher
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
end

class Sexp::Child < ::Sexp::Matcher
  def initialize(child); end

  def ==(o); end
  def child; end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
end

class Sexp::Include < ::Sexp::Matcher
  def initialize(value); end

  def ==(o); end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
  def value; end
end

class Sexp::Klass < ::Sexp::Pattern
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
end

Sexp::MAX_INT32 = T.let(T.unsafe(nil), Integer)

class Sexp::MatchCollection < ::Array
  def /(pattern); end
  def inspect; end
  def pretty_print(q); end
  def to_s; end
end

class Sexp::Matcher < ::Sexp
  def &(other); end
  def -@; end
  def /(sexp); end
  def ===(sexp); end
  def =~(sexp); end
  def >>(other); end
  def greedy?; end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
  def |(other); end

  class << self
    def match_subs=(o); end
    def match_subs?; end
    def parse(s); end
  end
end

class Sexp::Matcher::Parser
  def initialize(s); end

  def lex(s); end
  def next_token; end
  def parse; end
  def parse_cmd; end
  def parse_list; end
  def parse_sexp; end
  def peek_token; end
  def tokens; end
  def tokens=(_arg0); end
end

Sexp::Matcher::Parser::ALLOWED = T.let(T.unsafe(nil), Array)
Sexp::NODE_NAMES = T.let(T.unsafe(nil), Hash)

class Sexp::Not < ::Sexp::Matcher
  def initialize(value); end

  def ==(o); end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
  def value; end
end

class Sexp::Pattern < ::Sexp::Matcher
  def initialize(pattern); end

  def ==(o); end
  def eql?(o); end
  def hash; end
  def inspect; end
  def pattern; end
  def pretty_print(q); end
  def satisfy?(o); end
end

class Sexp::Remaining < ::Sexp::Matcher
  def greedy?; end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
end

class Sexp::Sibling < ::Sexp::Matcher
  def initialize(subject, sibling, distance = T.unsafe(nil)); end

  def ==(o); end
  def distance; end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
  def sibling; end
  def subject; end

  private

  def index_matches(pattern, o); end
end

class Sexp::Type < ::Sexp::Matcher
  def initialize(type); end

  def ==(o); end
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
  def sexp_type; end
end

Sexp::UNASSIGNED = T.let(T.unsafe(nil), Object)

class Sexp::Wild < ::Sexp::Matcher
  def inspect; end
  def pretty_print(q); end
  def satisfy?(o); end
end

class SexpInterpreter < ::SexpProcessor
  def initialize; end
end

class SexpProcessor
  def initialize; end

  def assert_empty(meth, exp, exp_orig); end
  def assert_type(list, typ); end
  def auto_shift_type; end
  def auto_shift_type=(_arg0); end
  def context; end
  def debug; end
  def debug=(_arg0); end
  def default_method; end
  def default_method=(_arg0); end
  def env; end
  def error_handler(type, exp = T.unsafe(nil)); end
  def expected; end
  def expected=(_arg0); end
  def in_context(type); end
  def on_error_in(node_type, &block); end
  def process(exp); end
  def process_dummy(exp); end
  def require_empty; end
  def require_empty=(_arg0); end
  def rewrite(exp); end
  def scope(&block); end
  def strict; end
  def strict=(_arg0); end
  def unsupported; end
  def unsupported=(_arg0); end
  def warn_on_default; end
  def warn_on_default=(_arg0); end

  class << self
    def expand_dirs_to_files(*dirs); end
    def processors; end
    def rewriters; end
  end
end

class SexpProcessor::Environment
  def initialize; end

  def [](name); end
  def []=(name, val); end
  def all; end
  def current; end
  def depth; end
  def scope; end
end

SexpProcessor::VERSION = T.let(T.unsafe(nil), String)
class SexpProcessorError < ::StandardError; end
class SexpTypeError < ::SexpProcessorError; end
class UnknownNodeError < ::SexpProcessorError; end
class UnsupportedNodeError < ::SexpProcessorError; end
