# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `irb` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

class Binding
  def irb; end
end

module IRB
  class << self
    def CurrentContext; end
    def Inspector(inspect, init = T.unsafe(nil)); end
    def conf; end
    def default_src_encoding; end
    def delete_caller; end
    def init_config(ap_path); end
    def init_error; end
    def irb_abort(irb, exception = T.unsafe(nil)); end
    def irb_at_exit; end
    def irb_exit(irb, ret); end
    def load_modules; end
    def parse_opts(argv: T.unsafe(nil)); end
    def rc_file(ext = T.unsafe(nil)); end
    def rc_file_generators; end
    def run_config; end
    def set_measure_callback(type = T.unsafe(nil), arg = T.unsafe(nil), &block); end
    def setup(ap_path, argv: T.unsafe(nil)); end
    def start(ap_path = T.unsafe(nil)); end
    def unset_measure_callback(type = T.unsafe(nil)); end
    def version; end

    private

    def easter_egg(type = T.unsafe(nil)); end
    def set_encoding(extern, intern = T.unsafe(nil), override: T.unsafe(nil)); end
  end
end

module IRB::Color
  class << self
    def clear(colorable: T.unsafe(nil)); end
    def colorable?; end
    def colorize(text, seq, colorable: T.unsafe(nil)); end
    def colorize_code(code, complete: T.unsafe(nil), ignore_error: T.unsafe(nil), colorable: T.unsafe(nil)); end
    def inspect_colorable?(obj, seen: T.unsafe(nil)); end

    private

    def dispatch_seq(token, expr, str, in_symbol:); end
    def scan(code, allow_last_error:); end
    def without_circular_ref(obj, seen:, &block); end
  end
end

IRB::Color::ALL = T.let(T.unsafe(nil), Integer)
IRB::Color::BLUE = T.let(T.unsafe(nil), Integer)
IRB::Color::BOLD = T.let(T.unsafe(nil), Integer)
IRB::Color::CLEAR = T.let(T.unsafe(nil), Integer)
IRB::Color::CYAN = T.let(T.unsafe(nil), Integer)
IRB::Color::ERROR_TOKENS = T.let(T.unsafe(nil), Array)
IRB::Color::GREEN = T.let(T.unsafe(nil), Integer)
IRB::Color::MAGENTA = T.let(T.unsafe(nil), Integer)
IRB::Color::RED = T.let(T.unsafe(nil), Integer)
IRB::Color::REVERSE = T.let(T.unsafe(nil), Integer)

class IRB::Color::SymbolState
  def initialize; end

  def scan_token(token); end
end

IRB::Color::TOKEN_KEYWORDS = T.let(T.unsafe(nil), Hash)
IRB::Color::TOKEN_SEQ_EXPRS = T.let(T.unsafe(nil), Hash)
IRB::Color::UNDERLINE = T.let(T.unsafe(nil), Integer)
IRB::Color::YELLOW = T.let(T.unsafe(nil), Integer)

class IRB::Context
  def initialize(irb, workspace = T.unsafe(nil), input_method = T.unsafe(nil)); end

  def ap_name; end
  def ap_name=(_arg0); end
  def auto_indent_mode; end
  def auto_indent_mode=(_arg0); end
  def back_trace_limit; end
  def back_trace_limit=(_arg0); end
  def echo; end
  def echo=(_arg0); end
  def echo?; end
  def echo_on_assignment; end
  def echo_on_assignment=(_arg0); end
  def echo_on_assignment?; end
  def eval_history=(*opts, &b); end
  def evaluate(line, line_no, exception: T.unsafe(nil)); end
  def exit(ret = T.unsafe(nil)); end
  def file_input?; end
  def ignore_eof; end
  def ignore_eof=(_arg0); end
  def ignore_eof?; end
  def ignore_sigint; end
  def ignore_sigint=(_arg0); end
  def ignore_sigint?; end
  def inspect; end
  def inspect?; end
  def inspect_last_value; end
  def inspect_mode; end
  def inspect_mode=(opt); end
  def io; end
  def io=(_arg0); end
  def irb; end
  def irb=(_arg0); end
  def irb_name; end
  def irb_name=(_arg0); end
  def irb_path; end
  def irb_path=(_arg0); end
  def last_value; end
  def load_modules; end
  def load_modules=(_arg0); end
  def main; end
  def newline_before_multiline_output; end
  def newline_before_multiline_output=(_arg0); end
  def newline_before_multiline_output?; end
  def prompt_c; end
  def prompt_c=(_arg0); end
  def prompt_i; end
  def prompt_i=(_arg0); end
  def prompt_mode; end
  def prompt_mode=(mode); end
  def prompt_n; end
  def prompt_n=(_arg0); end
  def prompt_s; end
  def prompt_s=(_arg0); end
  def prompting?; end
  def rc; end
  def rc=(_arg0); end
  def rc?; end
  def return_format; end
  def return_format=(_arg0); end
  def save_history=(*opts, &b); end
  def set_last_value(value); end
  def thread; end
  def to_s; end
  def use_colorize; end
  def use_colorize?; end
  def use_loader=(*opts, &b); end
  def use_multiline; end
  def use_multiline?; end
  def use_readline; end
  def use_readline?; end
  def use_reidline; end
  def use_reidline?; end
  def use_singleline; end
  def use_singleline?; end
  def use_tracer=(*opts, &b); end
  def verbose; end
  def verbose=(_arg0); end
  def verbose?; end
  def workspace; end
  def workspace=(_arg0); end
  def workspace_home; end
end

IRB::Context::IDNAME_IVARS = T.let(T.unsafe(nil), Array)
IRB::Context::NOPRINTING_IVARS = T.let(T.unsafe(nil), Array)
IRB::Context::NO_INSPECTING_IVARS = T.let(T.unsafe(nil), Array)

module IRB::ContextExtender
  class << self
    def def_extend_command(cmd_name, load_file, *aliases); end
    def install_extend_commands; end
  end
end

class IRB::DefaultEncodings < ::Struct
  def external; end
  def external=(_); end
  def internal; end
  def internal=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def members; end
    def new(*_arg0); end
  end
end

module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override = T.unsafe(nil)); end
  def irb(*opts, &b); end
  def irb_change_workspace(*opts, &b); end
  def irb_context; end
  def irb_current_working_workspace(*opts, &b); end
  def irb_exit(ret = T.unsafe(nil)); end
  def irb_fg(*opts, &b); end
  def irb_help(*opts, &b); end
  def irb_info(*opts, &b); end
  def irb_jobs(*opts, &b); end
  def irb_kill(*opts, &b); end
  def irb_load(*opts, &b); end
  def irb_ls(*opts, &b); end
  def irb_measure(*opts, &b); end
  def irb_pop_workspace(*opts, &b); end
  def irb_push_workspace(*opts, &b); end
  def irb_require(*opts, &b); end
  def irb_show_source(*opts, &b); end
  def irb_source(*opts, &b); end
  def irb_whereami(*opts, &b); end
  def irb_workspaces(*opts, &b); end

  class << self
    def def_extend_command(cmd_name, cmd_class, load_file = T.unsafe(nil), *aliases); end
    def extend_object(obj); end
    def install_extend_commands; end
    def irb_original_method_name(method_name); end
  end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

class IRB::FileInputMethod < ::IRB::InputMethod
  def initialize(file); end

  def close; end
  def encoding; end
  def eof?; end
  def file_name; end
  def gets; end
  def inspect; end

  class << self
    def open(file, &block); end
  end
end

IRB::IRBRC_EXT = T.let(T.unsafe(nil), String)

module IRB::InputCompletor
  class << self
    def ignored_modules; end
    def retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end
    def retrieve_files_to_require_from_load_path; end
    def retrieve_files_to_require_relative_from_current_dir; end
    def select_message(receiver, message, candidates, sep = T.unsafe(nil)); end
  end
end

IRB::InputCompletor::BASIC_WORD_BREAK_CHARACTERS = T.let(T.unsafe(nil), String)
IRB::InputCompletor::CompletionProc = T.let(T.unsafe(nil), Proc)
IRB::InputCompletor::CompletionRequireProc = T.let(T.unsafe(nil), Proc)
IRB::InputCompletor::Operators = T.let(T.unsafe(nil), Array)
IRB::InputCompletor::PerfectMatchedProc = T.let(T.unsafe(nil), Proc)
IRB::InputCompletor::ReservedWords = T.let(T.unsafe(nil), Array)

class IRB::InputMethod
  def initialize(file = T.unsafe(nil)); end

  def file_name; end
  def gets; end
  def inspect; end
  def prompt; end
  def prompt=(_arg0); end
  def readable_after_eof?; end
  def winsize; end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc = T.unsafe(nil)); end

  def init; end
  def inspect_value(v); end

  class << self
    def def_inspector(key, arg = T.unsafe(nil), &block); end
    def keys_with_inspector(inspector); end
  end
end

class IRB::Irb
  def initialize(workspace = T.unsafe(nil), input_method = T.unsafe(nil)); end

  def assignment_expression?(line); end
  def context; end
  def convert_invalid_byte_sequence(str, enc); end
  def encode_with_invalid_byte_sequence(str, enc); end
  def eval_input; end
  def handle_exception(exc); end
  def inspect; end
  def output_value(omit = T.unsafe(nil)); end
  def prompt(prompt, ltype, indent, line_no); end
  def run(conf = T.unsafe(nil)); end
  def scanner; end
  def scanner=(_arg0); end
  def signal_handle; end
  def signal_status(status); end
  def suspend_context(context); end
  def suspend_input_method(input_method); end
  def suspend_name(path = T.unsafe(nil), name = T.unsafe(nil)); end
  def suspend_workspace(workspace); end
end

IRB::Irb::ASSIGNMENT_NODE_TYPES = T.let(T.unsafe(nil), Array)

class IRB::Locale
  def initialize(locale = T.unsafe(nil)); end

  def String(mes); end
  def encoding; end
  def find(file, paths = T.unsafe(nil)); end
  def format(*opts); end
  def gets(*rs); end
  def lang; end
  def load(file, priv = T.unsafe(nil)); end
  def modifier; end
  def print(*opts); end
  def printf(*opts); end
  def puts(*opts); end
  def readline(*rs); end
  def require(file, priv = T.unsafe(nil)); end
  def territory; end

  private

  def each_localized_path(dir, file); end
  def each_sublocale; end
  def real_load(path, priv); end
  def search_file(lib_paths, dir, file); end
  def toplevel_load(*_arg0); end
end

IRB::Locale::LOCALE_DIR = T.let(T.unsafe(nil), String)
IRB::Locale::LOCALE_NAME_RE = T.let(T.unsafe(nil), Regexp)
IRB::MagicFile = T.let(T.unsafe(nil), Object)

module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end
  def def_pre_proc(base_method, extend_method); end
  def new_alias_name(name, prefix = T.unsafe(nil), postfix = T.unsafe(nil)); end
end

class IRB::OutputMethod
  def parse_printf_format(format, opts); end
  def pp(*objs); end
  def ppx(prefix, *objs); end
  def print(*opts); end
  def printf(format, *opts); end
  def printn(*opts); end
  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError < ::StandardError
  def initialize(val); end
end

class IRB::ReadlineInputMethod < ::IRB::InputMethod
  def initialize; end

  def encoding; end
  def eof?; end
  def gets; end
  def inspect; end
  def line(line_no); end
  def readable_after_eof?; end

  class << self
    def initialize_readline; end
  end
end

class IRB::ReidlineInputMethod < ::IRB::InputMethod
  include ::Reline

  def initialize; end

  def auto_indent(&block); end
  def check_termination(&block); end
  def dynamic_prompt(&block); end
  def encoding; end
  def eof?; end
  def gets; end
  def inspect; end
  def line(line_no); end
  def readable_after_eof?; end
end

IRB::STDIN_FILE_NAME = T.let(T.unsafe(nil), String)

class IRB::StdioInputMethod < ::IRB::InputMethod
  def initialize; end

  def encoding; end
  def eof?; end
  def gets; end
  def inspect; end
  def line(line_no); end
  def readable_after_eof?; end
end

class IRB::StdioOutputMethod < ::IRB::OutputMethod
  def print(*opts); end
end

IRB::VERSION = T.let(T.unsafe(nil), String)

class IRB::WorkSpace
  def initialize(*main); end

  def binding; end
  def code_around_binding; end
  def evaluate(context, statements, file = T.unsafe(nil), line = T.unsafe(nil)); end
  def filter_backtrace(bt); end
  def local_variable_get(name); end
  def local_variable_set(name, value); end
  def main; end
end

class RubyLex
  def initialize; end

  def check_code_block(code, tokens = T.unsafe(nil)); end
  def check_corresponding_token_depth; end
  def check_newline_depth_difference; end
  def check_state(code, tokens = T.unsafe(nil)); end
  def check_string_literal(tokens); end
  def check_termination_in_prev_line(code); end
  def each_top_level_statement; end
  def find_prev_spaces(line_index); end
  def initialize_input; end
  def is_method_calling?(tokens, index); end
  def is_the_in_correspond_to_a_for(tokens, index); end
  def lex; end
  def process_continue(tokens = T.unsafe(nil)); end
  def process_literal_type(tokens = T.unsafe(nil)); end
  def process_nesting_level(tokens = T.unsafe(nil)); end
  def prompt; end
  def set_auto_indent(context); end
  def set_input(io, p = T.unsafe(nil), &block); end
  def set_prompt(p = T.unsafe(nil), &block); end
  def take_corresponding_syntax_to_kw_do(tokens, index); end

  class << self
    def compile_with_errors_suppressed(code); end
    def ripper_lex_without_warning(code); end
  end
end

RubyLex::ERROR_TOKENS = T.let(T.unsafe(nil), Array)

class RubyLex::TerminateLineInput < ::StandardError
  def initialize; end
end
