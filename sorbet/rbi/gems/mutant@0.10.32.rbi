# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mutant` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module Mutant
  class << self
    def traverse(action, values); end
  end
end

module Mutant::AST
  class << self
    def find_last_path(node, &predicate); end

    private

    def walk(node, stack, &block); end
  end
end

class Mutant::AST::FindMetaclassContaining
  include ::Mutant::Procto
  include ::Unparser::Equalizer::Methods
  include ::Mutant::AST::NodePredicates
  extend ::Mutant::Procto::ClassMethods

  def call; end

  private

  def include_exact?(haystack, needle); end
  def metaclass_of?(sclass); end
  def transparently_contains?(body); end
end

Mutant::AST::FindMetaclassContaining::SCLASS_BODY_INDEX = T.let(T.unsafe(nil), Integer)
module Mutant::AST::Meta; end

class Mutant::AST::Meta::Const
  include ::Mutant::AST::NodePredicates
  include ::Unparser::Equalizer::Methods
  include ::Mutant::AST::NamedChildren
  include ::Mutant::AST::NamedChildren::InstanceMethods
  extend ::Mutant::AST::NamedChildren::ClassMethods

  def base; end
  def name; end
  def possible_top_level?; end

  private

  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::AST::Meta::Optarg
  include ::Unparser::Equalizer::Methods
  include ::Mutant::AST::NamedChildren
  include ::Mutant::AST::NamedChildren::InstanceMethods
  extend ::Mutant::AST::NamedChildren::ClassMethods

  def default_value; end
  def name; end
  def used?; end

  private

  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

Mutant::AST::Meta::Optarg::UNDERSCORE = T.let(T.unsafe(nil), String)

class Mutant::AST::Meta::Resbody
  include ::Unparser::Equalizer::Methods
  include ::Mutant::AST::NamedChildren
  include ::Mutant::AST::NamedChildren::InstanceMethods
  extend ::Mutant::AST::NamedChildren::ClassMethods

  def assignment; end
  def body; end
  def captures; end

  private

  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::AST::Meta::Send
  include ::Mutant::AST::NodePredicates
  include ::Unparser::Equalizer::Methods
  include ::Mutant::AST::NamedChildren
  include ::Mutant::AST::NamedChildren::InstanceMethods
  extend ::Mutant::AST::NamedChildren::ClassMethods

  def arguments; end
  def attribute_assignment?; end
  def binary_method_operator?; end
  def proc?; end
  def receiver; end
  def receiver_possible_top_level_const?; end
  def selector; end

  private

  def naked_proc?; end
  def proc_new?; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

Mutant::AST::Meta::Send::ATTRIBUTE_ASSIGNMENT_SELECTOR_SUFFIX = T.let(T.unsafe(nil), String)

class Mutant::AST::Meta::Symbol
  include ::Unparser::Equalizer::Methods
  include ::Mutant::AST::NamedChildren
  include ::Mutant::AST::NamedChildren::InstanceMethods
  extend ::Mutant::AST::NamedChildren::ClassMethods

  def name; end

  private

  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

module Mutant::AST::NamedChildren
  include ::Mutant::AST::NamedChildren::InstanceMethods

  mixes_in_class_methods ::Mutant::AST::NamedChildren::ClassMethods

  class << self
    def included(host); end
  end
end

module Mutant::AST::NamedChildren::ClassMethods
  private

  def children(*names); end
  def define_named_child(name, index); end
  def define_private_method(name, &block); end
  def define_remaining_children(names); end
end

module Mutant::AST::NamedChildren::InstanceMethods
  private

  def children; end
end

module Mutant::AST::NodePredicates
  private

  def n___ENCODING__?(node); end
  def n___FILE__?(node); end
  def n___LINE__?(node); end
  def n_alias?(node); end
  def n_and?(node); end
  def n_and_asgn?(node); end
  def n_arg?(node); end
  def n_arg_expr?(node); end
  def n_args?(node); end
  def n_array?(node); end
  def n_array_pattern?(node); end
  def n_array_pattern_with_tail?(node); end
  def n_back_ref?(node); end
  def n_begin?(node); end
  def n_block?(node); end
  def n_block_pass?(node); end
  def n_blockarg?(node); end
  def n_blockarg_expr?(node); end
  def n_break?(node); end
  def n_case?(node); end
  def n_case_match?(node); end
  def n_casgn?(node); end
  def n_cbase?(node); end
  def n_class?(node); end
  def n_complex?(node); end
  def n_const?(node); end
  def n_const_pattern?(node); end
  def n_csend?(node); end
  def n_cvar?(node); end
  def n_cvasgn?(node); end
  def n_def?(node); end
  def n_defined?(node); end
  def n_defs?(node); end
  def n_dstr?(node); end
  def n_dsym?(node); end
  def n_eflipflop?(node); end
  def n_empty?(node); end
  def n_empty_else?(node); end
  def n_ensure?(node); end
  def n_erange?(node); end
  def n_false?(node); end
  def n_find_pattern?(node); end
  def n_float?(node); end
  def n_for?(node); end
  def n_forward_arg?(node); end
  def n_forward_args?(node); end
  def n_forwarded_args?(node); end
  def n_gvar?(node); end
  def n_gvasgn?(node); end
  def n_hash?(node); end
  def n_hash_pattern?(node); end
  def n_ident?(node); end
  def n_if?(node); end
  def n_if_guard?(node); end
  def n_iflipflop?(node); end
  def n_in_match?(node); end
  def n_in_pattern?(node); end
  def n_index?(node); end
  def n_indexasgn?(node); end
  def n_int?(node); end
  def n_irange?(node); end
  def n_ivar?(node); end
  def n_ivasgn?(node); end
  def n_kwarg?(node); end
  def n_kwargs?(node); end
  def n_kwbegin?(node); end
  def n_kwnilarg?(node); end
  def n_kwoptarg?(node); end
  def n_kwrestarg?(node); end
  def n_kwsplat?(node); end
  def n_lambda?(node); end
  def n_lvar?(node); end
  def n_lvasgn?(node); end
  def n_masgn?(node); end
  def n_match_alt?(node); end
  def n_match_as?(node); end
  def n_match_current_line?(node); end
  def n_match_nil_pattern?(node); end
  def n_match_pattern?(node); end
  def n_match_pattern_p?(node); end
  def n_match_rest?(node); end
  def n_match_var?(node); end
  def n_match_with_lvasgn?(node); end
  def n_match_with_trailing_comma?(node); end
  def n_mlhs?(node); end
  def n_module?(node); end
  def n_next?(node); end
  def n_nil?(node); end
  def n_nth_ref?(node); end
  def n_numargs?(node); end
  def n_numblock?(node); end
  def n_objc_kwarg?(node); end
  def n_objc_restarg?(node); end
  def n_objc_varargs?(node); end
  def n_op_asgn?(node); end
  def n_optarg?(node); end
  def n_or?(node); end
  def n_or_asgn?(node); end
  def n_pair?(node); end
  def n_pin?(node); end
  def n_postexe?(node); end
  def n_preexe?(node); end
  def n_procarg0?(node); end
  def n_rational?(node); end
  def n_redo?(node); end
  def n_regexp?(node); end
  def n_regexp_alnum_posixclass?(node); end
  def n_regexp_alpha_posixclass?(node); end
  def n_regexp_alpha_property?(node); end
  def n_regexp_alternation_escape?(node); end
  def n_regexp_alternation_meta?(node); end
  def n_regexp_arabic_property?(node); end
  def n_regexp_ascii_posixclass?(node); end
  def n_regexp_atomic_group?(node); end
  def n_regexp_backslash_escape?(node); end
  def n_regexp_backspace_escape?(node); end
  def n_regexp_bell_escape?(node); end
  def n_regexp_blank_posixclass?(node); end
  def n_regexp_bol_anchor?(node); end
  def n_regexp_bol_escape?(node); end
  def n_regexp_bos_anchor?(node); end
  def n_regexp_capture_group?(node); end
  def n_regexp_carriage_escape?(node); end
  def n_regexp_character_set?(node); end
  def n_regexp_cntrl_posixclass?(node); end
  def n_regexp_codepoint_escape?(node); end
  def n_regexp_codepoint_list_escape?(node); end
  def n_regexp_comment_free_space?(node); end
  def n_regexp_comment_group?(node); end
  def n_regexp_condition_conditional?(node); end
  def n_regexp_control_escape?(node); end
  def n_regexp_digit_posixclass?(node); end
  def n_regexp_digit_type?(node); end
  def n_regexp_dot_escape?(node); end
  def n_regexp_dot_meta?(node); end
  def n_regexp_eol_anchor?(node); end
  def n_regexp_eol_escape?(node); end
  def n_regexp_eos_anchor?(node); end
  def n_regexp_eos_ob_eol_anchor?(node); end
  def n_regexp_escape_escape?(node); end
  def n_regexp_form_feed_escape?(node); end
  def n_regexp_graph_posixclass?(node); end
  def n_regexp_greedy_interval?(node); end
  def n_regexp_greedy_one_or_more?(node); end
  def n_regexp_greedy_zero_or_more?(node); end
  def n_regexp_greedy_zero_or_one?(node); end
  def n_regexp_group_close_escape?(node); end
  def n_regexp_group_open_escape?(node); end
  def n_regexp_han_property?(node); end
  def n_regexp_hangul_property?(node); end
  def n_regexp_hex_escape?(node); end
  def n_regexp_hex_type?(node); end
  def n_regexp_hiragana_property?(node); end
  def n_regexp_intersection_set?(node); end
  def n_regexp_interval_close_escape?(node); end
  def n_regexp_interval_open_escape?(node); end
  def n_regexp_katakana_property?(node); end
  def n_regexp_latin_property?(node); end
  def n_regexp_letter_property?(node); end
  def n_regexp_linebreak_type?(node); end
  def n_regexp_literal_escape?(node); end
  def n_regexp_literal_literal?(node); end
  def n_regexp_lookahead_assertion?(node); end
  def n_regexp_lookbehind_assertion?(node); end
  def n_regexp_lower_posixclass?(node); end
  def n_regexp_mark_keep?(node); end
  def n_regexp_match_start_anchor?(node); end
  def n_regexp_meta_sequence_escape?(node); end
  def n_regexp_name_call_backref?(node); end
  def n_regexp_named_group?(node); end
  def n_regexp_newline_escape?(node); end
  def n_regexp_nlookahead_assertion?(node); end
  def n_regexp_nlookbehind_assertion?(node); end
  def n_regexp_nondigit_type?(node); end
  def n_regexp_nonhex_type?(node); end
  def n_regexp_nonspace_type?(node); end
  def n_regexp_nonword_boundary_anchor?(node); end
  def n_regexp_nonword_type?(node); end
  def n_regexp_number_backref?(node); end
  def n_regexp_octal_escape?(node); end
  def n_regexp_one_or_more_escape?(node); end
  def n_regexp_open_conditional?(node); end
  def n_regexp_options_group?(node); end
  def n_regexp_options_switch_group?(node); end
  def n_regexp_passive_group?(node); end
  def n_regexp_possessive_interval?(node); end
  def n_regexp_possessive_one_or_more?(node); end
  def n_regexp_possessive_zero_or_more?(node); end
  def n_regexp_possessive_zero_or_one?(node); end
  def n_regexp_print_nonposixclass?(node); end
  def n_regexp_print_nonproperty?(node); end
  def n_regexp_print_posixclass?(node); end
  def n_regexp_print_property?(node); end
  def n_regexp_punct_posixclass?(node); end
  def n_regexp_range_set?(node); end
  def n_regexp_reluctant_interval?(node); end
  def n_regexp_reluctant_one_or_more?(node); end
  def n_regexp_reluctant_zero_or_more?(node); end
  def n_regexp_root_expression?(node); end
  def n_regexp_sequence_expression?(node); end
  def n_regexp_set_close_escape?(node); end
  def n_regexp_set_open_escape?(node); end
  def n_regexp_space_posixclass?(node); end
  def n_regexp_space_type?(node); end
  def n_regexp_tab_escape?(node); end
  def n_regexp_upper_posixclass?(node); end
  def n_regexp_vertical_tab_escape?(node); end
  def n_regexp_whitespace_free_space?(node); end
  def n_regexp_word_boundary_anchor?(node); end
  def n_regexp_word_posixclass?(node); end
  def n_regexp_word_type?(node); end
  def n_regexp_xdigit_posixclass?(node); end
  def n_regexp_xgrapheme_type?(node); end
  def n_regexp_zero_or_more_escape?(node); end
  def n_regexp_zero_or_one_escape?(node); end
  def n_regopt?(node); end
  def n_resbody?(node); end
  def n_rescue?(node); end
  def n_restarg?(node); end
  def n_restarg_expr?(node); end
  def n_retry?(node); end
  def n_return?(node); end
  def n_sclass?(node); end
  def n_self?(node); end
  def n_send?(node); end
  def n_shadowarg?(node); end
  def n_splat?(node); end
  def n_str?(node); end
  def n_super?(node); end
  def n_sym?(node); end
  def n_true?(node); end
  def n_undef?(node); end
  def n_unless_guard?(node); end
  def n_until?(node); end
  def n_until_post?(node); end
  def n_when?(node); end
  def n_while?(node); end
  def n_while_post?(node); end
  def n_xstr?(node); end
  def n_yield?(node); end
  def n_zsuper?(node); end
end

module Mutant::AST::Nodes
  extend ::Mutant::AST::Sexp
end

Mutant::AST::Nodes::N_EMPTY = T.let(T.unsafe(nil), Parser::AST::Node)
Mutant::AST::Nodes::N_EMPTY_SUPER = T.let(T.unsafe(nil), Parser::AST::Node)
Mutant::AST::Nodes::N_FALSE = T.let(T.unsafe(nil), Parser::AST::Node)
Mutant::AST::Nodes::N_INFINITY = T.let(T.unsafe(nil), Parser::AST::Node)
Mutant::AST::Nodes::N_NAN = T.let(T.unsafe(nil), Parser::AST::Node)
Mutant::AST::Nodes::N_NEGATIVE_INFINITY = T.let(T.unsafe(nil), Parser::AST::Node)
Mutant::AST::Nodes::N_NIL = T.let(T.unsafe(nil), Parser::AST::Node)
Mutant::AST::Nodes::N_RAISE = T.let(T.unsafe(nil), Parser::AST::Node)
Mutant::AST::Nodes::N_SELF = T.let(T.unsafe(nil), Parser::AST::Node)
Mutant::AST::Nodes::N_TRUE = T.let(T.unsafe(nil), Parser::AST::Node)
Mutant::AST::Nodes::N_ZSUPER = T.let(T.unsafe(nil), Parser::AST::Node)

module Mutant::AST::Regexp
  class << self
    def expand_regexp_ast(node); end
    def parse(regexp); end
    def to_ast(expression); end
    def to_expression(node); end
  end
end

class Mutant::AST::Regexp::Transformer
  include ::Unparser::AbstractType
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  class << self
    def lookup(type); end
    def new(*args, &block); end
    def to_ast(expression); end
    def to_expression(node); end

    private

    def register(type); end
  end
end

class Mutant::AST::Regexp::Transformer::ASTToExpression
  extend ::Mutant::Procto::ClassMethods
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::AbstractType
  include ::Mutant::Procto
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  include ::Unparser::Adamantium

  def call; end
  def transform(*_arg0); end

  private

  def subexpressions; end

  class << self
    def new(*args, &block); end
  end
end

class Mutant::AST::Regexp::Transformer::Direct < ::Mutant::AST::Regexp::Transformer; end

class Mutant::AST::Regexp::Transformer::Direct::ASTToExpression < ::Mutant::AST::Regexp::Transformer::ASTToExpression
  include ::Mutant::AST::Regexp::Transformer::LookupTable

  private

  def transform; end
end

Mutant::AST::Regexp::Transformer::Direct::ASTToExpression::TABLE = T.let(T.unsafe(nil), Mutant::AST::Regexp::Transformer::LookupTable::Table)

class Mutant::AST::Regexp::Transformer::Direct::ExpressionToAST < ::Mutant::AST::Regexp::Transformer::ExpressionToAST
  def call; end
end

class Mutant::AST::Regexp::Transformer::ExpressionToAST
  extend ::Mutant::Procto::ClassMethods
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::AbstractType
  include ::Mutant::AST::Sexp
  include ::Mutant::Procto
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  include ::Unparser::Adamantium

  private

  def ast(*children); end
  def children; end
  def quantify(node); end
  def type; end

  class << self
    def new(*args, &block); end
  end
end

Mutant::AST::Regexp::Transformer::ExpressionToAST::PREFIX = T.let(T.unsafe(nil), Symbol)

module Mutant::AST::Regexp::Transformer::LookupTable
  private

  def expression_class; end
  def expression_token; end
end

class Mutant::AST::Regexp::Transformer::LookupTable::Mapping
  include ::Unparser::Equalizer::Methods
end

class Mutant::AST::Regexp::Transformer::LookupTable::Table
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def lookup(type); end
  def types; end

  class << self
    def create(*rows); end
  end
end

class Mutant::AST::Regexp::Transformer::NamedGroup < ::Mutant::AST::Regexp::Transformer; end

class Mutant::AST::Regexp::Transformer::NamedGroup::ASTToExpression < ::Mutant::AST::Regexp::Transformer::ASTToExpression
  include ::Mutant::AST::NamedChildren
  include ::Mutant::AST::NamedChildren::InstanceMethods
  extend ::Mutant::AST::NamedChildren::ClassMethods

  private

  def name; end
  def named_group; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def subexpressions; end
  def transform; end
end

class Mutant::AST::Regexp::Transformer::NamedGroup::ExpressionToAST < ::Mutant::AST::Regexp::Transformer::ExpressionToAST
  def call; end
end

class Mutant::AST::Regexp::Transformer::OptionsGroup < ::Mutant::AST::Regexp::Transformer; end

class Mutant::AST::Regexp::Transformer::OptionsGroup::ASTToExpression < ::Mutant::AST::Regexp::Transformer::ASTToExpression
  include ::Mutant::AST::NamedChildren
  include ::Mutant::AST::NamedChildren::InstanceMethods
  extend ::Mutant::AST::NamedChildren::ClassMethods

  private

  def option_changes; end
  def options_group; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def subexpressions; end
  def text; end
  def transform; end
  def type; end
end

class Mutant::AST::Regexp::Transformer::OptionsGroup::ExpressionToAST < ::Mutant::AST::Regexp::Transformer::ExpressionToAST
  def call; end
end

class Mutant::AST::Regexp::Transformer::Quantifier < ::Mutant::AST::Regexp::Transformer; end

class Mutant::AST::Regexp::Transformer::Quantifier::ASTToExpression < ::Mutant::AST::Regexp::Transformer::ASTToExpression
  include ::Mutant::AST::NamedChildren
  include ::Mutant::AST::NamedChildren::InstanceMethods
  extend ::Mutant::AST::NamedChildren::ClassMethods

  private

  def interval_text; end
  def max; end
  def min; end
  def mode; end
  def quantifier; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def subject; end
  def suffix; end
  def text; end
  def transform; end
  def type; end
end

Mutant::AST::Regexp::Transformer::Quantifier::ASTToExpression::QUANTIFIER_MAP = T.let(T.unsafe(nil), Hash)

class Mutant::AST::Regexp::Transformer::Quantifier::ASTToExpression::Quantifier
  include ::Unparser::Equalizer::Methods
end

class Mutant::AST::Regexp::Transformer::Quantifier::ExpressionToAST < ::Mutant::AST::Regexp::Transformer::ExpressionToAST
  def call; end

  private

  def type; end
end

Mutant::AST::Regexp::Transformer::REGISTRY = T.let(T.unsafe(nil), Mutant::Registry)
class Mutant::AST::Regexp::Transformer::Recursive < ::Mutant::AST::Regexp::Transformer; end

class Mutant::AST::Regexp::Transformer::Recursive::ASTToExpression < ::Mutant::AST::Regexp::Transformer::ASTToExpression
  include ::Mutant::AST::Regexp::Transformer::LookupTable

  private

  def transform; end
end

Mutant::AST::Regexp::Transformer::Recursive::ASTToExpression::TABLE = T.let(T.unsafe(nil), Mutant::AST::Regexp::Transformer::LookupTable::Table)

class Mutant::AST::Regexp::Transformer::Recursive::ExpressionToAST < ::Mutant::AST::Regexp::Transformer::ExpressionToAST
  def call; end
end

class Mutant::AST::Regexp::Transformer::Root < ::Mutant::AST::Regexp::Transformer; end

class Mutant::AST::Regexp::Transformer::Root::ASTToExpression < ::Mutant::AST::Regexp::Transformer::ASTToExpression
  private

  def transform; end
end

class Mutant::AST::Regexp::Transformer::Root::ExpressionToAST < ::Mutant::AST::Regexp::Transformer::Recursive::ExpressionToAST; end
class Mutant::AST::Regexp::Transformer::Text < ::Mutant::AST::Regexp::Transformer; end

class Mutant::AST::Regexp::Transformer::Text::ASTToExpression < ::Mutant::AST::Regexp::Transformer::ASTToExpression
  include ::Mutant::AST::Regexp::Transformer::LookupTable

  private

  def transform; end
end

Mutant::AST::Regexp::Transformer::Text::ASTToExpression::TABLE = T.let(T.unsafe(nil), Mutant::AST::Regexp::Transformer::LookupTable::Table)

class Mutant::AST::Regexp::Transformer::Text::ExpressionToAST < ::Mutant::AST::Regexp::Transformer::ExpressionToAST
  def call; end
end

module Mutant::AST::Sexp
  private

  def n_not(node); end
  def s(type, *children); end
end

module Mutant::AST::Types; end
Mutant::AST::Types::ALL = T.let(T.unsafe(nil), Set)
Mutant::AST::Types::ASSIGNABLE_VARIABLES = T.let(T.unsafe(nil), Set)
Mutant::AST::Types::BINARY_METHOD_OPERATORS = T.let(T.unsafe(nil), Set)
Mutant::AST::Types::BLACKLIST = T.let(T.unsafe(nil), Set)
Mutant::AST::Types::GENERATED = T.let(T.unsafe(nil), Set)
Mutant::AST::Types::INDEX_OPERATORS = T.let(T.unsafe(nil), Set)
Mutant::AST::Types::METHOD_OPERATORS = T.let(T.unsafe(nil), Set)
Mutant::AST::Types::NOT_STANDALONE = T.let(T.unsafe(nil), Set)
Mutant::AST::Types::OP_ASSIGN = T.let(T.unsafe(nil), Set)
Mutant::AST::Types::REGEXP = T.let(T.unsafe(nil), Set)
Mutant::AST::Types::UNARY_METHOD_OPERATORS = T.let(T.unsafe(nil), Set)
Mutant::AbstractType = Unparser::AbstractType
Mutant::Adamantium = Unparser::Adamantium
Mutant::Anima = Unparser::Anima

module Mutant::Bootstrap
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods

  def config; end
  def parser; end
  def world; end

  class << self
    def anima; end
    def call(world, config); end

    private

    def expression(reporter, expression_parser, scope); end
    def infect(env); end
    def load_hooks(env); end
    def matchable_scopes(world, config); end
    def scope_name(reporter, scope); end
    def semantics_warning(reporter, format, options); end
    def start_subject(env, subjects); end
  end
end

Mutant::Bootstrap::CLASS_NAME_RAISED_EXCEPTION = T.let(T.unsafe(nil), String)
Mutant::Bootstrap::CLASS_NAME_TYPE_MISMATCH_FORMAT = T.let(T.unsafe(nil), String)
Mutant::Bootstrap::SEMANTICS_MESSAGE_FORMAT = T.let(T.unsafe(nil), String)

module Mutant::CLI
  class << self
    def parse(world:, **attributes); end
  end
end

class Mutant::CLI::Command
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::AbstractType
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  def arguments; end
  def call; end
  def full_name; end
  def main; end
  def parent; end
  def world; end
  def zombie?; end

  private

  def add_global_options(parser); end
  def add_subcommands(parser); end
  def add_summary(parser); end
  def banner; end
  def capture_main(&block); end
  def execute; end
  def fail_message(message); end
  def find_command(name); end
  def format_subcommands; end
  def parse; end
  def parse_remaining(remaining); end
  def parse_remaining_arguments(remaining); end
  def parse_subcommand(arguments); end
  def parser; end
  def print(message); end
  def subcommands; end
  def with_help(message); end

  class << self
    def anima; end
    def command_name; end
    def new(*args, &block); end
    def parse(**attributes); end
    def short_description; end
  end
end

class Mutant::CLI::Command::Environment < ::Mutant::CLI::Command
  def initialize(attributes); end

  private

  def add(attribute, value); end
  def add_environment_options(parser); end
  def add_integration_options(parser); end
  def add_matcher(attribute, value); end
  def add_matcher_options(parser); end
  def add_runner_options(parser); end
  def bootstrap; end
  def expand(file_config); end
  def matcher(**attributes); end
  def parse_remaining_arguments(arguments); end
  def set(**attributes); end
end

Mutant::CLI::Command::Environment::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::OPTIONS = T.let(T.unsafe(nil), Array)

class Mutant::CLI::Command::Environment::Run < ::Mutant::CLI::Command::Environment
  def zombie?; end

  private

  def action; end
  def from_result(result); end
  def soft_fail(result); end
  def unlicensed(message); end
end

Mutant::CLI::Command::Environment::Run::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Run::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Run::SLEEP = T.let(T.unsafe(nil), Integer)
Mutant::CLI::Command::Environment::Run::SUBCOMMANDS = T.let(T.unsafe(nil), Array)
Mutant::CLI::Command::Environment::Run::UNLICENSED = T.let(T.unsafe(nil), Array)
Mutant::CLI::Command::Environment::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::SUBCOMMANDS = T.let(T.unsafe(nil), Array)

class Mutant::CLI::Command::Environment::Show < ::Mutant::CLI::Command::Environment
  private

  def action; end
  def report_env(env); end
end

Mutant::CLI::Command::Environment::Show::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Show::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Show::SUBCOMMANDS = T.let(T.unsafe(nil), Array)
class Mutant::CLI::Command::Environment::Subject < ::Mutant::CLI::Command::Environment; end

class Mutant::CLI::Command::Environment::Subject::List < ::Mutant::CLI::Command::Environment::Subject
  private

  def action; end
  def list_subjects(env); end
end

Mutant::CLI::Command::Environment::Subject::List::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Subject::List::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Subject::List::SUBCOMMANDS = T.let(T.unsafe(nil), Array)
Mutant::CLI::Command::Environment::Subject::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Subject::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Subject::SUBCOMMANDS = T.let(T.unsafe(nil), Array)
class Mutant::CLI::Command::Environment::Test < ::Mutant::CLI::Command::Environment; end

class Mutant::CLI::Command::Environment::Test::List < ::Mutant::CLI::Command::Environment::Test
  private

  def action; end
  def list_tests(env); end
end

Mutant::CLI::Command::Environment::Test::List::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Test::List::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Test::List::SUBCOMMANDS = T.let(T.unsafe(nil), Array)
Mutant::CLI::Command::Environment::Test::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Test::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Environment::Test::SUBCOMMANDS = T.let(T.unsafe(nil), Array)

class Mutant::CLI::Command::FailParse < ::Mutant::CLI::Command
  def call; end
end

Mutant::CLI::Command::OPTIONS = T.let(T.unsafe(nil), Array)

class Mutant::CLI::Command::OptionParser < ::OptionParser
  def add_officious; end
end

class Mutant::CLI::Command::Root < ::Mutant::CLI::Command; end
Mutant::CLI::Command::Root::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Root::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Root::SUBCOMMANDS = T.let(T.unsafe(nil), Array)
Mutant::CLI::Command::SUBCOMMANDS = T.let(T.unsafe(nil), Array)

class Mutant::CLI::Command::Subscription < ::Mutant::CLI::Command
  private

  def license; end
end

Mutant::CLI::Command::Subscription::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Subscription::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Subscription::SUBCOMMANDS = T.let(T.unsafe(nil), Array)

class Mutant::CLI::Command::Subscription::Show < ::Mutant::CLI::Command::Subscription
  private

  def execute; end
  def licensed(subscription); end
  def unlicensed(message); end
end

Mutant::CLI::Command::Subscription::Show::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Subscription::Show::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Subscription::Show::SUBCOMMANDS = T.let(T.unsafe(nil), Array)

class Mutant::CLI::Command::Subscription::Test < ::Mutant::CLI::Command::Subscription
  private

  def execute; end
end

Mutant::CLI::Command::Subscription::Test::NAME = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Subscription::Test::SHORT_DESCRIPTION = T.let(T.unsafe(nil), String)
Mutant::CLI::Command::Subscription::Test::SUBCOMMANDS = T.let(T.unsafe(nil), Array)
Mutant::Concord = Unparser::Concord

class Mutant::Config
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def coverage_criteria; end
  def expand_defaults; end
  def expression_parser; end
  def fail_fast; end
  def fail_fast?; end
  def hooks; end
  def includes; end
  def integration; end
  def isolation; end
  def jobs; end
  def matcher; end
  def merge(other); end
  def mutation_timeout; end
  def reporter; end
  def requires; end
  def zombie; end
  def zombie?; end

  class << self
    def anima; end
    def env; end
    def load_config_file(world); end

    private

    def load_contents(path); end
  end
end

Mutant::Config::CANDIDATES = T.let(T.unsafe(nil), Array)

class Mutant::Config::CoverageCriteria
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def merge(other); end
  def process_abort; end
  def test_result; end
  def timeout; end

  private

  def overwrite(other, attribute_name); end

  class << self
    def anima; end
  end
end

Mutant::Config::CoverageCriteria::DEFAULT = T.let(T.unsafe(nil), Mutant::Config::CoverageCriteria)
Mutant::Config::CoverageCriteria::EMPTY = T.let(T.unsafe(nil), Mutant::Config::CoverageCriteria)
Mutant::Config::CoverageCriteria::TRANSFORM = T.let(T.unsafe(nil), Mutant::Transform::Sequence)
Mutant::Config::DEFAULT = T.let(T.unsafe(nil), Mutant::Config)
Mutant::Config::MORE_THAN_ONE_CONFIG_FILE = T.let(T.unsafe(nil), String)
Mutant::Config::PATHNAME_ARRAY = T.let(T.unsafe(nil), Mutant::Transform::Array)
Mutant::Config::TRANSFORM = T.let(T.unsafe(nil), Mutant::Transform::Sequence)

class Mutant::Context
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Mutant::AST::Sexp

  def identification; end
  def match_expressions(&block); end
  def nesting(&block); end
  def root(node); end
  def scope; end
  def unqualified_name; end

  private

  def name_nesting(&block); end

  class << self
    def wrap(scope, node); end
  end
end

Mutant::Context::NAMESPACE_DELIMITER = T.let(T.unsafe(nil), String)
Mutant::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)
Mutant::EMPTY_HASH = T.let(T.unsafe(nil), Hash)
Mutant::EMPTY_STRING = T.let(T.unsafe(nil), String)
Mutant::Either = Unparser::Either

class Mutant::Env
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def amount_mutations(&block); end
  def amount_selected_tests(&block); end
  def amount_subjects(&block); end
  def amount_total_tests(&block); end
  def config; end
  def cover_index(mutation_index); end
  def hooks; end
  def integration; end
  def matchable_scopes; end
  def mutations; end
  def parser; end
  def selected_tests(&block); end
  def selections(&block); end
  def selector; end
  def subjects; end
  def test_subject_ratio(&block); end
  def warn(message); end
  def world; end

  private

  def run_mutation_tests(mutation, tests); end
  def timer; end

  class << self
    def anima; end
    def empty(world, config); end
  end
end

Mutant::Env::SEMANTICS_MESSAGE = T.let(T.unsafe(nil), String)
Mutant::Equalizer = Unparser::Equalizer

class Mutant::Expression
  def match_length(other); end
  def prefix?(other); end

  class << self
    def new(*_arg0); end
    def try_parse(input); end

    private

    def from_match(match); end
  end
end

class Mutant::Expression::Method < ::Mutant::Expression
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Mutant::AST::Sexp

  def initialize(*_arg0); end

  def matcher; end
  def syntax; end

  private

  def method_name; end
  def scope; end
  def scope_name; end
  def scope_symbol; end

  class << self
    def anima; end
    def try_parse(input); end

    private

    def valid_method_name?(name); end
  end
end

Mutant::Expression::Method::MATCHERS = T.let(T.unsafe(nil), Hash)
Mutant::Expression::Method::METHOD_NAME_PATTERN = T.let(T.unsafe(nil), Regexp)
Mutant::Expression::Method::REGEXP = T.let(T.unsafe(nil), Regexp)

class Mutant::Expression::Methods < ::Mutant::Expression
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def initialize(*_arg0); end

  def match_length(expression); end
  def matcher; end
  def syntax; end

  private

  def scope; end
  def scope_name; end
  def scope_symbol; end

  class << self
    def anima; end
  end
end

Mutant::Expression::Methods::MATCHERS = T.let(T.unsafe(nil), Hash)
Mutant::Expression::Methods::REGEXP = T.let(T.unsafe(nil), Regexp)

class Mutant::Expression::Namespace < ::Mutant::Expression
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::AbstractType
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  private

  def scope_name; end

  class << self
    def anima; end
    def new(*args, &block); end
  end
end

class Mutant::Expression::Namespace::Exact < ::Mutant::Expression::Namespace
  def matcher; end
  def syntax; end

  private

  def find_scope; end
end

Mutant::Expression::Namespace::Exact::MATCHER = Mutant::Matcher::Scope
Mutant::Expression::Namespace::Exact::REGEXP = T.let(T.unsafe(nil), Regexp)

class Mutant::Expression::Namespace::Recursive < ::Mutant::Expression::Namespace
  def initialize(*_arg0); end

  def match_length(expression); end
  def matcher; end
  def syntax; end
end

Mutant::Expression::Namespace::Recursive::REGEXP = T.let(T.unsafe(nil), Regexp)

class Mutant::Expression::Parser
  include ::Unparser::Equalizer::Methods

  def call(input); end

  private

  def expressions(input); end
end

Mutant::Expression::SCOPE_NAME_PATTERN = T.let(T.unsafe(nil), Regexp)
Mutant::Expression::SCOPE_SYMBOL_PATTERN = T.let(T.unsafe(nil), String)

class Mutant::Hooks
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def merge(other); end
  def run(name, payload); end

  class << self
    def assert_name(name); end
    def empty; end
    def load_config(config); end
    def load_pathname(pathname); end
  end
end

class Mutant::Hooks::Builder
  def initialize; end

  def register(name, &block); end
  def to_hooks; end
end

Mutant::Hooks::DEFAULTS = T.let(T.unsafe(nil), Hash)
Mutant::Hooks::MESSAGE = T.let(T.unsafe(nil), String)
class Mutant::Hooks::UnknownHook < ::RuntimeError; end

class Mutant::Integration
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::AbstractType
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  include ::Unparser::Anima::InstanceMethods

  def all_tests(*_arg0); end
  def call(*_arg0); end
  def expression_parser; end
  def setup; end
  def world; end

  private

  def timer; end

  class << self
    def anima; end
    def new(*args, &block); end
    def setup(env); end

    private

    def attempt_const_get(env); end
    def attempt_require(env); end
  end
end

Mutant::Integration::CONST_MESSAGE = T.let(T.unsafe(nil), String)
Mutant::Integration::INTEGRATION_MISSING = T.let(T.unsafe(nil), String)
Mutant::Integration::LOAD_MESSAGE = T.let(T.unsafe(nil), String)

class Mutant::Integration::Null < ::Mutant::Integration
  def all_tests; end
  def call(_tests); end
end

class Mutant::Isolation
  include ::Unparser::AbstractType
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  def call(*_arg0); end

  class << self
    def new(*args, &block); end
  end
end

class Mutant::Isolation::Exception
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def backtrace; end
  def message; end
  def original_class; end

  class << self
    def anima; end
  end
end

class Mutant::Isolation::Fork < ::Mutant::Isolation
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def call(timeout, &block); end
end

Mutant::Isolation::Fork::ATTRIBUTES = T.let(T.unsafe(nil), Array)

class Mutant::Isolation::Fork::Child
  extend ::Unparser::Adamantium::ClassMethods
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Mutant::Procto::ClassMethods
  extend ::Unparser::Adamantium::ModuleMethods
  include ::Mutant::Procto

  def block; end
  def call; end
  def deadline; end
  def log_pipe; end
  def result_pipe; end
  def world; end

  class << self
    def anima; end
  end
end

class Mutant::Isolation::Fork::Parent
  include ::Mutant::Procto
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Mutant::Procto::ClassMethods

  def block; end
  def call; end
  def deadline; end
  def log_pipe; end
  def result_pipe; end
  def world; end

  private

  def add_result(result); end
  def handle_status(status); end
  def load_result(result_fragments); end
  def peek_child; end
  def read_child_result; end
  def read_fragment(target, fragments); end
  def read_targets(targets); end
  def result; end
  def start_child; end
  def terminate_graceful; end
  def terminate_ungraceful; end

  class << self
    def anima; end
  end
end

class Mutant::Isolation::Fork::Pipe
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def child; end
  def parent; end
  def reader; end
  def writer; end

  class << self
    def anima; end
    def with(io); end
  end
end

Mutant::Isolation::Fork::READ_SIZE = T.let(T.unsafe(nil), Integer)

class Mutant::Isolation::None < ::Mutant::Isolation
  def call(_timeout); end
end

class Mutant::Isolation::Result
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def exception; end
  def log; end
  def process_status; end
  def timeout; end
  def valid_value?; end
  def value; end

  class << self
    def anima; end
  end
end

module Mutant::License
  class << self
    def call(world); end

    private

    def check_for_rubygems_mutant_license(message); end
    def license_path(world); end
    def load_mutant_license(world); end
  end
end

Mutant::License::NAME = T.let(T.unsafe(nil), String)

class Mutant::License::Subscription
  include ::Unparser::Equalizer::Methods

  def description; end

  private

  def failure(expected, actual); end
  def failure_message(expected, actual); end
  def subscription_name; end
  def success; end

  class << self
    def load(world, value); end
  end
end

class Mutant::License::Subscription::Commercial < ::Mutant::License::Subscription
  def call(world); end

  private

  def candidates(world); end
  def capture(world, command); end
  def commit_author(world); end
  def git_author(world); end

  class << self
    def from_json(value); end
  end
end

class Mutant::License::Subscription::Commercial::Author
  include ::Unparser::Equalizer::Methods

  def to_s; end
end

Mutant::License::Subscription::FAILURE_FORMAT = T.let(T.unsafe(nil), String)
Mutant::License::Subscription::FORMAT = T.let(T.unsafe(nil), String)

class Mutant::License::Subscription::Opensource < ::Mutant::License::Subscription
  def call(world); end

  private

  def check_subscription(actual); end
  def parse_remotes(input); end

  class << self
    def from_json(value); end
  end
end

class Mutant::License::Subscription::Opensource::Repository
  include ::Unparser::Equalizer::Methods

  def to_s; end

  class << self
    def parse(input); end

    private

    def parse_remote(input); end
    def parse_url(input); end
  end
end

Mutant::License::Subscription::Opensource::Repository::GIT_HTTPS_REGEXP = T.let(T.unsafe(nil), Regexp)
Mutant::License::Subscription::Opensource::Repository::GIT_SSH_REGEXP = T.let(T.unsafe(nil), Regexp)
Mutant::License::Subscription::Opensource::Repository::REMOTE_REGEXP = T.let(T.unsafe(nil), Regexp)
Mutant::License::VERSION = T.let(T.unsafe(nil), Array)

class Mutant::Loader
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def binding; end
  def call; end
  def kernel; end
  def source; end
  def subject; end

  class << self
    def anima; end
    def call(*arguments); end
  end
end

Mutant::Loader::FROZEN_STRING_FORMAT = T.let(T.unsafe(nil), String)

class Mutant::Loader::Result
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  class << self
    def instance; end
  end
end

class Mutant::Loader::Result::Success < ::Mutant::Loader::Result
  class << self
    def instance; end
  end
end

class Mutant::Loader::Result::VoidValue < ::Mutant::Loader::Result
  class << self
    def instance; end
  end
end

Mutant::Loader::VOID_VALUE_REGEXP = T.let(T.unsafe(nil), Regexp)

class Mutant::Matcher
  include ::Unparser::AbstractType
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def call(*_arg0); end

  class << self
    def from_config(config); end
    def ignore_subject?(config, subject); end
    def new(*args, &block); end

    private

    def allowed_subject?(config, subject); end
    def select_subject?(config, subject); end
  end
end

class Mutant::Matcher::Chain < ::Mutant::Matcher
  include ::Unparser::Equalizer::Methods

  def call(env); end
end

class Mutant::Matcher::Config
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def add(attribute, value); end
  def ignore; end
  def inspect(&block); end
  def merge(other); end
  def start_expressions; end
  def subject_filters; end
  def subjects; end

  private

  def format_attribute(attribute_name); end
  def inspect_attributes; end
  def present_attributes; end

  class << self
    def anima; end
  end
end

Mutant::Matcher::Config::ATTRIBUTE_DELIMITER = T.let(T.unsafe(nil), String)
Mutant::Matcher::Config::ATTRIBUTE_FORMAT = T.let(T.unsafe(nil), String)
Mutant::Matcher::Config::DEFAULT = T.let(T.unsafe(nil), Mutant::Matcher::Config)
Mutant::Matcher::Config::EMPTY_ATTRIBUTES = T.let(T.unsafe(nil), String)
Mutant::Matcher::Config::ENUM_DELIMITER = T.let(T.unsafe(nil), String)
Mutant::Matcher::Config::INSPECT_FORMAT = T.let(T.unsafe(nil), String)
Mutant::Matcher::Config::LOADER = T.let(T.unsafe(nil), Mutant::Transform::Sequence)
Mutant::Matcher::Config::PRESENTATIONS = T.let(T.unsafe(nil), Hash)

class Mutant::Matcher::Filter < ::Mutant::Matcher
  include ::Unparser::Equalizer::Methods

  def call(env); end
end

class Mutant::Matcher::Method < ::Mutant::Matcher
  include ::Unparser::Equalizer::Methods

  def call(env); end

  class << self
    def new(*args, &block); end
  end
end

Mutant::Matcher::Method::CLOSURE_WARNING_FORMAT = T.let(T.unsafe(nil), String)

class Mutant::Matcher::Method::Evaluator
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  include ::Mutant::Procto
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::AbstractType
  extend ::Mutant::Procto::ClassMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  include ::Mutant::AST::NodePredicates

  def call; end

  private

  def ast; end
  def context; end
  def matched_node_path(&block); end
  def method_name; end
  def skip?; end
  def source_line; end
  def source_location; end
  def source_path(&block); end
  def subject(&block); end

  class << self
    def new(*args, &block); end
  end
end

class Mutant::Matcher::Method::Instance < ::Mutant::Matcher::Method
  class << self
    def new(scope, target_method); end

    private

    def memoized_method?(scope, method_name); end
  end
end

class Mutant::Matcher::Method::Instance::Evaluator < ::Mutant::Matcher::Method::Evaluator
  private

  def match?(node); end
end

class Mutant::Matcher::Method::Instance::Evaluator::Memoized < ::Mutant::Matcher::Method::Instance::Evaluator
  private

  def source_location; end
end

Mutant::Matcher::Method::Instance::Evaluator::Memoized::SUBJECT_CLASS = Mutant::Subject::Method::Instance::Memoized
Mutant::Matcher::Method::Instance::Evaluator::NAME_INDEX = T.let(T.unsafe(nil), Integer)
Mutant::Matcher::Method::Instance::Evaluator::SUBJECT_CLASS = Mutant::Subject::Method::Instance

class Mutant::Matcher::Method::Metaclass < ::Mutant::Matcher::Method
  class << self
    def new(scope, method_name); end
  end
end

class Mutant::Matcher::Method::Metaclass::Evaluator < ::Mutant::Matcher::Method::Evaluator
  private

  def line?(node); end
  def match?(node); end
  def metaclass_containing(node); end
  def metaclass_receiver?(node); end
  def metaclass_target?(node); end
  def name?(node); end
  def sclass_const_name?(node); end
end

Mutant::Matcher::Method::Metaclass::Evaluator::CONST_NAME_INDEX = T.let(T.unsafe(nil), Integer)
Mutant::Matcher::Method::Metaclass::Evaluator::NAME_INDEX = T.let(T.unsafe(nil), Integer)
Mutant::Matcher::Method::Metaclass::Evaluator::RECEIVER_WARNING = T.let(T.unsafe(nil), String)
Mutant::Matcher::Method::Metaclass::Evaluator::SCLASS_RECEIVER_INDEX = T.let(T.unsafe(nil), Integer)
Mutant::Matcher::Method::Metaclass::Evaluator::SUBJECT_CLASS = Mutant::Subject::Method::Metaclass
Mutant::Matcher::Method::SOURCE_LOCATION_WARNING_FORMAT = T.let(T.unsafe(nil), String)

class Mutant::Matcher::Method::Singleton < ::Mutant::Matcher::Method
  class << self
    def new(scope, method_name); end
  end
end

class Mutant::Matcher::Method::Singleton::Evaluator < ::Mutant::Matcher::Method::Evaluator
  private

  def line?(node); end
  def match?(node); end
  def name?(node); end
  def receiver?(node); end
  def receiver_name?(node); end
end

Mutant::Matcher::Method::Singleton::Evaluator::NAME_INDEX = T.let(T.unsafe(nil), Integer)
Mutant::Matcher::Method::Singleton::Evaluator::RECEIVER_INDEX = T.let(T.unsafe(nil), Integer)
Mutant::Matcher::Method::Singleton::Evaluator::RECEIVER_WARNING = T.let(T.unsafe(nil), String)
Mutant::Matcher::Method::Singleton::Evaluator::SUBJECT_CLASS = Mutant::Subject::Method::Singleton

class Mutant::Matcher::Methods < ::Mutant::Matcher
  include ::Unparser::Equalizer::Methods

  def call(env); end

  private

  def candidate_names; end
  def candidate_scope(*_arg0); end
  def matcher; end
  def methods(&block); end

  class << self
    def new(*args, &block); end
  end
end

Mutant::Matcher::Methods::CANDIDATE_NAMES = T.let(T.unsafe(nil), Array)

class Mutant::Matcher::Methods::Instance < ::Mutant::Matcher::Methods
  private

  def access(method_name); end
  def candidate_scope; end
end

Mutant::Matcher::Methods::Instance::MATCHER = Mutant::Matcher::Method::Instance

class Mutant::Matcher::Methods::Metaclass < ::Mutant::Matcher::Methods
  private

  def access(method_name); end
  def candidate_scope; end
end

Mutant::Matcher::Methods::Metaclass::MATCHER = Mutant::Matcher::Method::Metaclass

class Mutant::Matcher::Methods::Singleton < ::Mutant::Matcher::Methods
  private

  def access(method_name); end
  def candidate_scope; end
end

Mutant::Matcher::Methods::Singleton::MATCHER = Mutant::Matcher::Method::Singleton

class Mutant::Matcher::Namespace < ::Mutant::Matcher
  include ::Unparser::Equalizer::Methods

  def call(env); end

  private

  def match?(scope); end
  def matched_scopes(env); end
end

class Mutant::Matcher::Null < ::Mutant::Matcher
  include ::Unparser::Equalizer::Methods

  def call(_env); end
end

class Mutant::Matcher::Scope < ::Mutant::Matcher
  include ::Unparser::Equalizer::Methods

  def call(env); end

  private

  def effective_matchers; end
end

Mutant::Matcher::Scope::MATCHERS = T.let(T.unsafe(nil), Array)

class Mutant::Matcher::Static
  include ::Unparser::Equalizer::Methods

  def call(_env); end
end

class Mutant::Mutation
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::AbstractType
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  def code(&block); end
  def identification(&block); end
  def insert(kernel); end
  def monkeypatch(&block); end
  def original_source; end
  def source(&block); end

  private

  def sha1; end

  class << self
    def new(*args, &block); end
    def success?(test_result); end
  end
end

Mutant::Mutation::CODE_DELIMITER = T.let(T.unsafe(nil), String)
Mutant::Mutation::CODE_RANGE = T.let(T.unsafe(nil), Range)
class Mutant::Mutation::Evil < ::Mutant::Mutation; end
Mutant::Mutation::Evil::SYMBOL = T.let(T.unsafe(nil), String)
class Mutant::Mutation::Neutral < ::Mutant::Mutation; end
Mutant::Mutation::Neutral::SYMBOL = T.let(T.unsafe(nil), String)
Mutant::Mutation::Neutral::TEST_PASS_SUCCESS = T.let(T.unsafe(nil), TrueClass)
class Mutant::Mutation::Noop < ::Mutant::Mutation::Neutral; end
Mutant::Mutation::Noop::SYMBOL = T.let(T.unsafe(nil), String)
Mutant::Mutation::Noop::TEST_PASS_SUCCESS = T.let(T.unsafe(nil), TrueClass)

class Mutant::Mutator
  extend ::Unparser::Adamantium::ClassMethods
  include ::Unparser::AbstractType
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Mutant::Procto::ClassMethods
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  extend ::Unparser::Adamantium::ModuleMethods
  include ::Mutant::Procto

  def initialize(_input, _parent = T.unsafe(nil)); end

  def call; end
  def output; end

  private

  def dispatch(*_arg0); end
  def dup_input; end
  def emit(object); end
  def new?(object); end
  def run(mutator); end

  class << self
    def mutate(node, parent = T.unsafe(nil)); end
    def new(*args, &block); end

    private

    def handle(*types); end
  end
end

class Mutant::Mutator::Node < ::Mutant::Mutator
  include ::Unparser::Constants
  include ::Mutant::AST::Nodes
  include ::Mutant::AST::Sexp
  include ::Mutant::AST::NodePredicates
  include ::Mutant::AST::NamedChildren
  include ::Mutant::AST::NamedChildren::InstanceMethods
  extend ::Mutant::AST::NamedChildren::ClassMethods

  protected

  def node; end

  private

  def children_indices(range); end
  def delete_child(index); end
  def dup_node; end
  def emit_child_update(index, node); end
  def emit_nil; end
  def emit_propagation(node); end
  def emit_singletons; end
  def emit_type(*children); end
  def left_op_assignment?; end
  def mutate_child(index, &block); end
  def mutate_single_child; end
  def parent_node; end
  def parent_type; end

  class << self
    def new(*args, &block); end

    private

    def define_named_child(name, index); end
  end
end

class Mutant::Mutator::Node::AndAsgn < ::Mutant::Mutator::Node
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end

  private

  def dispatch; end
  def left; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end

class Mutant::Mutator::Node::Argument < ::Mutant::Mutator::Node
  def emit_name(node); end
  def emit_name_mutations(&block); end

  private

  def dispatch; end
  def emit_name_mutation; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def skip?; end
end

class Mutant::Mutator::Node::Argument::Optional < ::Mutant::Mutator::Node::Argument
  def emit_default(node); end
  def emit_default_mutations(&block); end
  def emit_name(node); end
  def emit_name_mutations(&block); end

  private

  def default; end
  def dispatch; end
  def emit_required_mutation; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

Mutant::Mutator::Node::Argument::Optional::TYPE_MAP = T.let(T.unsafe(nil), Hash)
Mutant::Mutator::Node::Argument::UNDERSCORE = T.let(T.unsafe(nil), String)

class Mutant::Mutator::Node::Arguments < ::Mutant::Mutator::Node
  private

  def dispatch; end
  def emit_argument_mutations; end
  def emit_argument_presence; end
  def emit_mlhs_expansion; end
  def invalid_argument_replacement?(mutant, index); end
  def mlhs_childs_with_index; end
end

class Mutant::Mutator::Node::Begin < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Binary < ::Mutant::Mutator::Node
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end

  private

  def dispatch; end
  def emit_left_negation; end
  def emit_operator_mutations; end
  def emit_promotions; end
  def left; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end

Mutant::Mutator::Node::Binary::INVERSE = T.let(T.unsafe(nil), Hash)

class Mutant::Mutator::Node::Block < ::Mutant::Mutator::Node
  def emit_arguments(node); end
  def emit_arguments_mutations(&block); end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_send(node); end
  def emit_send_mutations(&block); end

  private

  def arguments; end
  def body; end
  def body_has_control?; end
  def dispatch; end
  def mutate_body; end
  def mutate_body_receiver; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def send; end
  def unconditional_loop?; end
  def valid_send_mutation?(node); end
end

class Mutant::Mutator::Node::BlockPass < ::Mutant::Mutator::Node
  def emit_argument(node); end
  def emit_argument_mutations(&block); end

  private

  def argument; end
  def dispatch; end
  def emit_symbol_to_proc_mutations; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Break < ::Mutant::Mutator::Node::Generic
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Case < ::Mutant::Mutator::Node
  def emit_condition(node); end
  def emit_condition_mutations(&block); end

  private

  def condition; end
  def dispatch; end
  def emit_else_mutations; end
  def emit_when_mutations; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Class < ::Mutant::Mutator::Node
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_klass(node); end
  def emit_klass_mutations(&block); end
  def emit_parent(node); end
  def emit_parent_mutations(&block); end

  private

  def body; end
  def dispatch; end
  def klass; end
  def parent; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::ConditionalLoop < ::Mutant::Mutator::Node
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_condition(node); end
  def emit_condition_mutations(&block); end

  private

  def body; end
  def condition; end
  def dispatch; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Const < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Define < ::Mutant::Mutator::Node
  private

  def dispatch; end
  def emit_body_prepend(node); end
  def emit_optarg_body_assignments; end
end

class Mutant::Mutator::Node::Define::Instance < ::Mutant::Mutator::Node::Define
  def emit_arguments(node); end
  def emit_arguments_mutations(&block); end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_name(node); end
  def emit_name_mutations(&block); end

  private

  def arguments; end
  def body; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Define::Singleton < ::Mutant::Mutator::Node::Define
  def emit_arguments(node); end
  def emit_arguments_mutations(&block); end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_name(node); end
  def emit_name_mutations(&block); end
  def emit_subject(node); end
  def emit_subject_mutations(&block); end

  private

  def arguments; end
  def body; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def subject; end
end

class Mutant::Mutator::Node::Defined < ::Mutant::Mutator::Node
  def emit_expression(node); end
  def emit_expression_mutations(&block); end

  private

  def dispatch; end
  def emit_instance_variable_mutation; end
  def expression; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::DynamicLiteral < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Generic < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::If < ::Mutant::Mutator::Node
  def emit_condition(node); end
  def emit_condition_mutations(&block); end
  def emit_else_branch(node); end
  def emit_else_branch_mutations(&block); end
  def emit_if_branch(node); end
  def emit_if_branch_mutations(&block); end

  private

  def condition; end
  def dispatch; end
  def else_branch; end
  def if_branch; end
  def mutate_condition; end
  def mutate_else_branch; end
  def mutate_if_branch; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Index < ::Mutant::Mutator::Node
  def emit_receiver(node); end
  def emit_receiver_mutations(&block); end

  private

  def dispatch; end
  def emit_drop_mutation; end
  def emit_send_forms; end
  def indices; end
  def mutate_indices; end
  def receiver; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Index::Assign < ::Mutant::Mutator::Node::Index
  private

  def dispatch; end
  def emit_index_read; end
  def index_range; end
end

Mutant::Mutator::Node::Index::Assign::REGULAR_RANGE = T.let(T.unsafe(nil), Range)
Mutant::Mutator::Node::Index::NO_VALUE_RANGE = T.let(T.unsafe(nil), Range)

class Mutant::Mutator::Node::Index::Read < ::Mutant::Mutator::Node::Index
  private

  def index_range; end
end

Mutant::Mutator::Node::Index::SEND_REPLACEMENTS = T.let(T.unsafe(nil), Array)

class Mutant::Mutator::Node::Kwargs < ::Mutant::Mutator::Node
  private

  def dispatch; end
  def emit_argument_mutations; end
  def emit_argument_presence; end
  def forbid_argument?(node); end
end

Mutant::Mutator::Node::Kwargs::DISALLOW = T.let(T.unsafe(nil), Array)

class Mutant::Mutator::Node::Kwbegin < ::Mutant::Mutator::Node::Generic
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Literal < ::Mutant::Mutator::Node
  private

  def emit_values; end

  class << self
    def new(*args, &block); end
  end
end

class Mutant::Mutator::Node::Literal::Array < ::Mutant::Mutator::Node::Literal
  def emit_first(node); end
  def emit_first_mutations(&block); end

  private

  def dispatch; end
  def first; end
  def mutate_body; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Literal::Boolean < ::Mutant::Mutator::Node::Literal
  private

  def dispatch; end
end

Mutant::Mutator::Node::Literal::Boolean::MAP = T.let(T.unsafe(nil), Hash)

class Mutant::Mutator::Node::Literal::Float < ::Mutant::Mutator::Node::Literal
  private

  def dispatch; end
  def emit_special_cases; end
  def values; end
end

Mutant::Mutator::Node::Literal::Float::SPECIAL = T.let(T.unsafe(nil), Array)

class Mutant::Mutator::Node::Literal::Hash < ::Mutant::Mutator::Node::Literal
  private

  def dispatch; end
  def mutate_body; end
end

class Mutant::Mutator::Node::Literal::Hash::Pair < ::Mutant::Mutator::Node
  def emit_key(node); end
  def emit_key_mutations(&block); end
  def emit_value(node); end
  def emit_value_mutations(&block); end

  private

  def dispatch; end
  def key; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
end

class Mutant::Mutator::Node::Literal::Integer < ::Mutant::Mutator::Node::Literal
  def emit_value(node); end
  def emit_value_mutations(&block); end

  private

  def dispatch; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
  def values; end
end

class Mutant::Mutator::Node::Literal::Nil < ::Mutant::Mutator::Node::Literal
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Literal::Range < ::Mutant::Mutator::Node::Literal
  def emit_lower_bound(node); end
  def emit_lower_bound_mutations(&block); end
  def emit_upper_bound(node); end
  def emit_upper_bound_mutations(&block); end

  private

  def dispatch; end
  def emit_inverse; end
  def lower_bound; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def upper_bound; end
end

Mutant::Mutator::Node::Literal::Range::MAP = T.let(T.unsafe(nil), Hash)

class Mutant::Mutator::Node::Literal::Regex < ::Mutant::Mutator::Node::Literal
  private

  def dispatch; end
  def mutate_body; end
  def options; end
end

Mutant::Mutator::Node::Literal::Regex::NULL_REGEXP_SOURCE = T.let(T.unsafe(nil), String)

class Mutant::Mutator::Node::Literal::String < ::Mutant::Mutator::Node::Literal
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Literal::Symbol < ::Mutant::Mutator::Node::Literal
  def emit_value(node); end
  def emit_value_mutations(&block); end

  private

  def dispatch; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
end

class Mutant::Mutator::Node::MLHS < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::MatchCurrentLine < ::Mutant::Mutator::Node
  def emit_regexp(node); end
  def emit_regexp_mutations(&block); end

  private

  def dispatch; end
  def regexp; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Module < ::Mutant::Mutator::Node
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_klass(node); end
  def emit_klass_mutations(&block); end

  private

  def body; end
  def dispatch; end
  def klass; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::MultipleAssignment < ::Mutant::Mutator::Node
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end

  private

  def dispatch; end
  def left; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end

module Mutant::Mutator::Node::NamedValue; end

class Mutant::Mutator::Node::NamedValue::Access < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::NamedValue::Access::Ivar < ::Mutant::Mutator::Node::NamedValue::Access
  def emit_name(node); end
  def emit_name_mutations(&block); end

  private

  def attribute_name; end
  def dispatch; end
  def emit_attribute_read; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

Mutant::Mutator::Node::NamedValue::Access::Ivar::NAME_RANGE = T.let(T.unsafe(nil), Range)

class Mutant::Mutator::Node::NamedValue::ConstantAssignment < ::Mutant::Mutator::Node
  def emit_cbase(node); end
  def emit_cbase_mutations(&block); end
  def emit_name(node); end
  def emit_name_mutations(&block); end
  def emit_value(node); end
  def emit_value_mutations(&block); end

  private

  def cbase; end
  def dispatch; end
  def emit_remove_const; end
  def mutate_name; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
end

class Mutant::Mutator::Node::NamedValue::VariableAssignment < ::Mutant::Mutator::Node
  def emit_name(node); end
  def emit_name_mutations(&block); end
  def emit_value(node); end
  def emit_value_mutations(&block); end

  private

  def dispatch; end
  def mutate_name; end
  def name; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
end

Mutant::Mutator::Node::NamedValue::VariableAssignment::MAP = T.let(T.unsafe(nil), Hash)

class Mutant::Mutator::Node::Next < ::Mutant::Mutator::Node::Generic
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Noop < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::NthRef < ::Mutant::Mutator::Node
  def emit_number(node); end
  def emit_number_mutations(&block); end

  private

  def dispatch; end
  def number; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::OpAsgn < ::Mutant::Mutator::Node
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_operation(node); end
  def emit_operation_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end

  private

  def dispatch; end
  def emit_left_promotion; end
  def left; end
  def left_mutations; end
  def operation; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end

class Mutant::Mutator::Node::OrAsgn < ::Mutant::Mutator::Node
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end

  private

  def dispatch; end
  def left; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end

class Mutant::Mutator::Node::ProcargZero < ::Mutant::Mutator::Node
  def emit_argument(node); end
  def emit_argument_mutations(&block); end

  private

  def argument; end
  def dispatch; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

module Mutant::Mutator::Node::Regexp; end

class Mutant::Mutator::Node::Regexp::AlternationMeta < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Regexp::BeginningOfLineAnchor < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Regexp::CaptureGroup < ::Mutant::Mutator::Node
  def emit_group(node); end
  def emit_group_mutations(&block); end

  private

  def dispatch; end
  def group; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Regexp::CharacterType < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

Mutant::Mutator::Node::Regexp::CharacterType::MAP = T.let(T.unsafe(nil), Hash)

class Mutant::Mutator::Node::Regexp::EndOfLineAnchor < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Regexp::EndOfStringOrBeforeEndOfLineAnchor < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Regexp::NamedGroup < ::Mutant::Mutator::Node
  def emit_group(node); end
  def emit_group_mutations(&block); end
  def emit_name(node); end
  def emit_name_mutations(&block); end

  private

  def dispatch; end
  def emit_name_underscore_mutation; end
  def group; end
  def name; end
  def name_underscored?; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Regexp::RootExpression < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

class Mutant::Mutator::Node::Regexp::ZeroOrMore < ::Mutant::Mutator::Node
  def emit_max(node); end
  def emit_max_mutations(&block); end
  def emit_min(node); end
  def emit_min_mutations(&block); end
  def emit_subject(node); end
  def emit_subject_mutations(&block); end

  private

  def dispatch; end
  def max; end
  def min; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def subject; end
end

Mutant::Mutator::Node::Regexp::ZeroOrMore::MAP = T.let(T.unsafe(nil), Hash)

class Mutant::Mutator::Node::Regopt < ::Mutant::Mutator::Node
  private

  def dispatch; end
  def mutated_flags; end
end

Mutant::Mutator::Node::Regopt::MUTATED_FLAGS = T.let(T.unsafe(nil), Array)

class Mutant::Mutator::Node::Resbody < ::Mutant::Mutator::Node
  def emit_assignment(node); end
  def emit_assignment_mutations(&block); end
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_captures(node); end
  def emit_captures_mutations(&block); end

  private

  def assignment; end
  def body; end
  def captures; end
  def dispatch; end
  def mutate_captures; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Rescue < ::Mutant::Mutator::Node
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_else_body(node); end
  def emit_else_body_mutations(&block); end

  private

  def body; end
  def dispatch; end
  def else_body; end
  def emit_concat(child); end
  def mutate_body; end
  def mutate_else_body; end
  def mutate_rescue_bodies; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

Mutant::Mutator::Node::Rescue::RESCUE_INDICES = T.let(T.unsafe(nil), Range)

class Mutant::Mutator::Node::Return < ::Mutant::Mutator::Node
  def emit_value(node); end
  def emit_value_mutations(&block); end

  private

  def dispatch; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def value; end
end

class Mutant::Mutator::Node::Sclass < ::Mutant::Mutator::Node
  def emit_body(node); end
  def emit_body_mutations(&block); end
  def emit_expr(node); end
  def emit_expr_mutations(&block); end

  private

  def body; end
  def dispatch; end
  def expr; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Send < ::Mutant::Mutator::Node
  include ::Mutant::AST::Types

  def emit_receiver(node); end
  def emit_receiver_mutations(&block); end
  def emit_selector(node); end
  def emit_selector_mutations(&block); end

  private

  def arguments; end
  def dispatch; end
  def emit_argument_propagation; end
  def emit_array_mutation; end
  def emit_const_get_mutation; end
  def emit_dig_mutation; end
  def emit_double_negation_mutation; end
  def emit_end_with(regexp_nodes); end
  def emit_explicit_self; end
  def emit_implicit_self; end
  def emit_integer_mutation; end
  def emit_lambda_mutation; end
  def emit_naked_receiver; end
  def emit_predicate_mutations; end
  def emit_receiver_selector_mutations; end
  def emit_reduce_to_sum_mutation; end
  def emit_selector_replacement; end
  def emit_selector_specific_mutations; end
  def emit_start_end_with_mutations; end
  def emit_start_with(regexp_nodes); end
  def emit_static_send; end
  def meta(&block); end
  def mutate_argument_index(index); end
  def mutate_arguments; end
  def mutate_receiver; end
  def normal_dispatch; end
  def possible_kernel_method?; end
  def receiver; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def selector; end
end

class Mutant::Mutator::Node::Send::AttributeAssignment < ::Mutant::Mutator::Node::Send
  private

  def dispatch; end
  def emit_attribute_read; end
  def mutate_arguments; end
end

Mutant::Mutator::Node::Send::AttributeAssignment::ATTRIBUTE_RANGE = T.let(T.unsafe(nil), Range)

class Mutant::Mutator::Node::Send::Binary < ::Mutant::Mutator::Node::Send
  def emit_left(node); end
  def emit_left_mutations(&block); end
  def emit_operator(node); end
  def emit_operator_mutations(&block); end
  def emit_right(node); end
  def emit_right_mutations(&block); end

  private

  def dispatch; end
  def emit_not_equality_mutation(new_operator); end
  def emit_not_equality_mutations; end
  def left; end
  def operator; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
  def right; end
end

class Mutant::Mutator::Node::Send::Conditional < ::Mutant::Mutator::Node::Send
  private

  def dispatch; end
end

Mutant::Mutator::Node::Send::RECEIVER_SELECTOR_REPLACEMENTS = T.let(T.unsafe(nil), Hash)
Mutant::Mutator::Node::Send::REGEXP_END_WITH_NODES = T.let(T.unsafe(nil), Array)
Mutant::Mutator::Node::Send::REGEXP_MATCH_METHODS = T.let(T.unsafe(nil), Array)
Mutant::Mutator::Node::Send::REGEXP_START_WITH_NODES = T.let(T.unsafe(nil), Array)
Mutant::Mutator::Node::Send::SELECTOR_REPLACEMENTS = T.let(T.unsafe(nil), Hash)

class Mutant::Mutator::Node::Splat < ::Mutant::Mutator::Node
  def emit_expression(node); end
  def emit_expression_mutations(&block); end

  private

  def dispatch; end
  def expression; end
  def remaining_children; end
  def remaining_children_indices; end
  def remaining_children_with_index; end
end

class Mutant::Mutator::Node::Super < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

Mutant::Mutator::Node::TAUTOLOGY = T.let(T.unsafe(nil), Proc)

class Mutant::Mutator::Node::When < ::Mutant::Mutator::Node
  private

  def body; end
  def body_index; end
  def dispatch; end
  def mutate_body; end
  def mutate_conditions; end
end

class Mutant::Mutator::Node::Yield < ::Mutant::Mutator::Node::Generic
  private

  def dispatch; end
end

class Mutant::Mutator::Node::ZSuper < ::Mutant::Mutator::Node
  private

  def dispatch; end
end

Mutant::Mutator::REGISTRY = T.let(T.unsafe(nil), Mutant::Registry)
class Mutant::Mutator::Util < ::Mutant::Mutator; end
class Mutant::Mutator::Util::Array < ::Mutant::Mutator::Util; end

class Mutant::Mutator::Util::Array::Element < ::Mutant::Mutator::Util
  private

  def dispatch; end
end

class Mutant::Mutator::Util::Array::Presence < ::Mutant::Mutator::Util
  private

  def dispatch; end
end

class Mutant::Mutator::Util::Symbol < ::Mutant::Mutator::Util
  private

  def dispatch; end
end

Mutant::Mutator::Util::Symbol::POSTFIX = T.let(T.unsafe(nil), String)

module Mutant::Parallel
  class << self
    def async(world, config); end

    private

    def shared(klass, world, **attributes); end
    def shared_state(world, config); end
    def threads(world, config, workers); end
    def workers(world, config, shared); end
  end
end

class Mutant::Parallel::Config
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def block; end
  def jobs; end
  def process_name; end
  def sink; end
  def source; end
  def thread_name; end

  class << self
    def anima; end
  end
end

class Mutant::Parallel::Driver
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def wait_timeout(timeout); end

  private

  def finalize(status); end
  def status; end
  def threads; end
  def var_active_jobs; end
  def var_final; end
  def var_running; end
  def var_sink; end
  def var_source; end
  def workers; end

  class << self
    def anima; end
  end
end

class Mutant::Parallel::Sink
  include ::Unparser::AbstractType
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  def result(*_arg0); end
  def status(*_arg0); end
  def stop?(*_arg0); end

  class << self
    def new(*args, &block); end
  end
end

class Mutant::Parallel::Source
  include ::Unparser::AbstractType
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  def next(*_arg0); end
  def next?(*_arg0); end

  class << self
    def new(*args, &block); end
  end
end

class Mutant::Parallel::Source::Array
  include ::Unparser::Equalizer::Methods

  def initialize(*_arg0); end

  def next; end
  def next?; end
end

class Mutant::Parallel::Source::Job
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def index; end
  def payload; end

  class << self
    def anima; end
  end
end

class Mutant::Parallel::Source::NoJobError < ::RuntimeError; end

class Mutant::Parallel::Status
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def active_jobs; end
  def done; end
  def done?; end
  def payload; end

  class << self
    def anima; end
  end
end

class Mutant::Parallel::Worker
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def call; end
  def index; end
  def join; end

  private

  def add_result(result); end
  def connection; end
  def finalize; end
  def job_done(job); end
  def job_start(job); end
  def next_job; end
  def pid; end
  def process; end
  def var_active_jobs; end
  def var_final; end
  def var_running; end
  def var_sink; end
  def var_source; end

  class << self
    def anima; end
    def start(world:, block:, process_name:, **attributes); end
  end
end

class Mutant::Parallel::Worker::Child
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def block; end
  def call; end
  def connection; end

  class << self
    def anima; end
  end
end

class Mutant::Parser
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def initialize; end

  def call(path); end
end

class Mutant::Pipe
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def reader; end
  def to_reader; end
  def to_writer; end
  def writer; end

  class << self
    def anima; end
    def from_io(io); end
    def with(io); end
  end
end

class Mutant::Pipe::Connection
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def call(payload); end
  def marshal; end
  def reader; end
  def receive_value; end
  def send_value(value); end
  def writer; end

  class << self
    def anima; end
    def from_pipes(marshal:, reader:, writer:); end
  end
end

class Mutant::Pipe::Connection::Error < ::RuntimeError; end

class Mutant::Pipe::Connection::Frame
  include ::Unparser::Equalizer::Methods

  def receive_value; end
  def send_value(body); end

  private

  def read(bytes); end
end

Mutant::Pipe::Connection::Frame::HEADER_FORMAT = T.let(T.unsafe(nil), String)
Mutant::Pipe::Connection::Frame::HEADER_SIZE = T.let(T.unsafe(nil), Integer)
Mutant::Pipe::Connection::Frame::MAX_BYTES = T.let(T.unsafe(nil), Integer)

module Mutant::Procto
  mixes_in_class_methods ::Mutant::Procto::ClassMethods

  class << self
    def included(host); end
  end
end

module Mutant::Procto::ClassMethods
  def call(*arguments); end
end

module Mutant::Range
  class << self
    def overlap?(left, right); end
  end
end

class Mutant::Registry
  include ::Unparser::Equalizer::Methods

  def initialize(default); end

  def lookup(type); end
  def register(type, klass); end
end

class Mutant::Registry::RegistryError < ::TypeError; end

class Mutant::Reporter
  include ::Unparser::AbstractType
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  def delay(*_arg0); end
  def progress(*_arg0); end
  def report(*_arg0); end
  def start(*_arg0); end
  def warn(*_arg0); end

  class << self
    def new(*args, &block); end
  end
end

class Mutant::Reporter::CLI < ::Mutant::Reporter
  include ::Unparser::Equalizer::Methods

  def delay; end
  def progress(status); end
  def report(env); end
  def start(env); end
  def warn(message); end

  private

  def write(frame); end

  class << self
    def build(output); end
  end
end

class Mutant::Reporter::CLI::Format
  include ::Unparser::Equalizer::Methods
  include ::Unparser::AbstractType
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  def delay; end
  def progress(*_arg0); end
  def start(*_arg0); end

  private

  def format(printer, object); end

  class << self
    def new(*args, &block); end
  end
end

class Mutant::Reporter::CLI::Format::Output
  include ::Unparser::Equalizer::Methods

  def puts(*args, &block); end
  def tty?; end
  def write(*args, &block); end
end

class Mutant::Reporter::CLI::Format::Progressive < ::Mutant::Reporter::CLI::Format
  def progress(status); end
  def start(env); end

  private

  def new_buffer; end
end

Mutant::Reporter::CLI::Format::Progressive::REPORT_DELAY = T.let(T.unsafe(nil), Float)
Mutant::Reporter::CLI::Format::Progressive::REPORT_FREQUENCY = T.let(T.unsafe(nil), Float)

class Mutant::Reporter::CLI::Printer
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::AbstractType
  extend ::Mutant::Procto::ClassMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  include ::Mutant::Procto

  def call; end
  def run(*_arg0); end

  private

  def color?; end
  def colorize(color, message); end
  def info(string, *arguments); end
  def puts(string); end
  def status(string, *arguments); end
  def status_color; end
  def success?; end
  def tty?; end
  def visit(printer, object); end
  def visit_collection(printer, collection); end

  class << self
    private

    def define_delegator(name); end
    def delegate(*names); end
    def new(*args, &block); end
  end
end

class Mutant::Reporter::CLI::Printer::Config < ::Mutant::Reporter::CLI::Printer
  def run; end
end

class Mutant::Reporter::CLI::Printer::CoverageResult < ::Mutant::Reporter::CLI::Printer
  def run; end
end

class Mutant::Reporter::CLI::Printer::Env < ::Mutant::Reporter::CLI::Printer
  def run; end

  private

  def amount_mutations; end
  def amount_selected_tests; end
  def amount_subjects; end
  def amount_total_tests; end
  def config; end
  def test_subject_ratio; end
end

Mutant::Reporter::CLI::Printer::Env::FORMATS = T.let(T.unsafe(nil), Array)

class Mutant::Reporter::CLI::Printer::EnvProgress < ::Mutant::Reporter::CLI::Printer
  def run; end

  private

  def amount_mutation_results; end
  def amount_mutations_alive; end
  def amount_mutations_killed; end
  def amount_timeouts; end
  def coverage; end
  def coverage_percent; end
  def env; end
  def killtime; end
  def mutations_per_second; end
  def overhead; end
  def overhead_percent; end
  def runtime; end
end

Mutant::Reporter::CLI::Printer::EnvProgress::FORMATS = T.let(T.unsafe(nil), Array)

class Mutant::Reporter::CLI::Printer::EnvResult < ::Mutant::Reporter::CLI::Printer
  def run; end

  private

  def failed_subject_results; end
end

class Mutant::Reporter::CLI::Printer::IsolationResult < ::Mutant::Reporter::CLI::Printer
  def run; end

  private

  def print_exception; end
  def print_log_messages; end
  def print_process_status; end
  def print_timeout; end
end

Mutant::Reporter::CLI::Printer::IsolationResult::EXCEPTION_ERROR_MESSAGE = T.let(T.unsafe(nil), String)
Mutant::Reporter::CLI::Printer::IsolationResult::PROCESS_ERROR_MESSAGE = T.let(T.unsafe(nil), String)
Mutant::Reporter::CLI::Printer::IsolationResult::TIMEOUT_ERROR_MESSAGE = T.let(T.unsafe(nil), String)

class Mutant::Reporter::CLI::Printer::MutationResult < ::Mutant::Reporter::CLI::Printer
  def run; end

  private

  def evil_details; end
  def isolation_result; end
  def mutation; end
  def neutral_details; end
  def noop_details; end
  def original_node; end
  def print_details; end
  def print_no_diff_message; end
end

Mutant::Reporter::CLI::Printer::MutationResult::MAP = T.let(T.unsafe(nil), Hash)
Mutant::Reporter::CLI::Printer::MutationResult::NEUTRAL_MESSAGE = T.let(T.unsafe(nil), String)
Mutant::Reporter::CLI::Printer::MutationResult::NOOP_MESSAGE = T.let(T.unsafe(nil), String)
Mutant::Reporter::CLI::Printer::MutationResult::NO_DIFF_MESSAGE = T.let(T.unsafe(nil), String)
Mutant::Reporter::CLI::Printer::MutationResult::SEPARATOR = T.let(T.unsafe(nil), String)
Mutant::Reporter::CLI::Printer::NL = T.let(T.unsafe(nil), String)

class Mutant::Reporter::CLI::Printer::StatusProgressive < ::Mutant::Reporter::CLI::Printer
  def run; end

  private

  def amount_mutation_results; end
  def amount_mutations; end
  def amount_mutations_alive; end
  def amount_mutations_killed; end
  def killtime; end
  def mutations_per_second; end
  def object; end
  def overhead; end
  def runtime; end
end

Mutant::Reporter::CLI::Printer::StatusProgressive::FORMAT = T.let(T.unsafe(nil), String)

class Mutant::Reporter::CLI::Printer::SubjectResult < ::Mutant::Reporter::CLI::Printer
  def run; end

  private

  def subject; end
  def tests; end
  def uncovered_results; end
end

class Mutant::Reporter::Null < ::Mutant::Reporter
  include ::Unparser::Equalizer::Methods

  def progress(_object); end
  def report(_object); end
  def start(_object); end
  def warn(_object); end
end

class Mutant::Reporter::Sequence < ::Mutant::Reporter
  include ::Unparser::Equalizer::Methods

  def delay; end
  def progress(value); end
  def report(value); end
  def start(value); end
  def warn(value); end
end

module Mutant::Repository; end

class Mutant::Repository::Diff
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def to; end
  def touches?(path, line_range); end
  def world; end

  private

  def diff_index(root); end
  def parse_line(root, line); end
  def repository_root; end
  def touched_paths(&block); end

  class << self
    def anima; end
  end
end

class Mutant::Repository::Diff::Error < ::RuntimeError; end
Mutant::Repository::Diff::FORMAT = T.let(T.unsafe(nil), Regexp)

class Mutant::Repository::Diff::Path
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def path; end
  def to; end
  def touches?(line_range); end
  def world; end

  private

  def diff_ranges(&block); end

  class << self
    def anima; end
  end
end

Mutant::Repository::Diff::Path::DECIMAL = T.let(T.unsafe(nil), Regexp)
Mutant::Repository::Diff::Path::REGEXP = T.let(T.unsafe(nil), Regexp)

module Mutant::Repository::Diff::Ranges
  class << self
    def parse(diff); end

    private

    def mk_range(start, offset); end
    def parse_ranges(line); end
  end
end

Mutant::Repository::Diff::Ranges::DECIMAL = T.let(T.unsafe(nil), Regexp)
Mutant::Repository::Diff::Ranges::REGEXP = T.let(T.unsafe(nil), Regexp)

class Mutant::Repository::SubjectFilter
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def call(subject); end
end

module Mutant::RequireHighjack
  class << self
    def call(target, callback); end
  end
end

module Mutant::Result
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::Adamantium

  mixes_in_class_methods ::Mutant::Result::ClassMethods

  def overhead; end

  class << self
    def included(host); end
  end
end

module Mutant::Result::ClassMethods
  def delegate(name, target); end
  def sum(name, collection); end
end

class Mutant::Result::Coverage
  extend ::Mutant::Result::ClassMethods
  include ::Unparser::Equalizer::Methods
  include ::Mutant::Result
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  include ::Unparser::Anima::InstanceMethods

  def criteria_result; end
  def killtime; end
  def mutation_result; end
  def runtime; end
  def success?; end
  def timeout?; end

  class << self
    def anima; end
  end
end

class Mutant::Result::CoverageCriteria
  extend ::Mutant::Result::ClassMethods
  include ::Unparser::Equalizer::Methods
  include ::Mutant::Result
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  include ::Unparser::Anima::InstanceMethods

  def process_abort; end
  def success?; end
  def test_result; end
  def timeout; end

  class << self
    def anima; end
  end
end

module Mutant::Result::CoverageMetric
  def coverage; end
end

Mutant::Result::CoverageMetric::FULL_COVERAGE = T.let(T.unsafe(nil), Rational)

class Mutant::Result::Env
  extend ::Mutant::Result::ClassMethods
  include ::Unparser::Equalizer::Methods
  include ::Mutant::Result
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Mutant::Result::CoverageMetric
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  include ::Unparser::Anima::InstanceMethods

  def amount_mutation_results(&block); end
  def amount_mutations; end
  def amount_mutations_alive(&block); end
  def amount_mutations_killed(&block); end
  def amount_timeouts(&block); end
  def env; end
  def failed_subject_results; end
  def killtime(&block); end
  def runtime; end
  def stop?; end
  def subject_results; end
  def success?(&block); end

  class << self
    def anima; end
  end
end

class Mutant::Result::Mutation
  extend ::Mutant::Result::ClassMethods
  include ::Unparser::Equalizer::Methods
  include ::Mutant::Result
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  include ::Unparser::Anima::InstanceMethods

  def criteria_result(coverage_criteria); end
  def isolation_result; end
  def killtime; end
  def mutation; end
  def process_abort?; end
  def runtime; end
  def timeout?; end

  private

  def test_result_success?(&block); end

  class << self
    def anima; end
  end
end

class Mutant::Result::MutationIndex
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def isolation_result; end
  def mutation_index; end
  def runtime; end

  class << self
    def anima; end
  end
end

class Mutant::Result::Subject
  extend ::Mutant::Result::ClassMethods
  include ::Unparser::Equalizer::Methods
  include ::Mutant::Result
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Mutant::Result::CoverageMetric
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  include ::Unparser::Anima::InstanceMethods

  def amount_mutation_results; end
  def amount_mutations; end
  def amount_mutations_alive; end
  def amount_mutations_killed; end
  def amount_timeouts; end
  def coverage_results; end
  def killtime(&block); end
  def runtime(&block); end
  def subject; end
  def success?; end
  def tests; end
  def uncovered_results(&block); end

  private

  def covered_results(&block); end

  class << self
    def anima; end
  end
end

class Mutant::Result::Test
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def passed; end
  def runtime; end

  class << self
    def anima; end
  end
end

class Mutant::Result::Test::VoidValue < ::Mutant::Result::Test
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  def initialize; end

  class << self
    def instance; end
  end
end

module Mutant::Runner
  class << self
    def call(env); end

    private

    def mutation_test_config(env); end
    def reporter(env); end
    def run_driver(reporter, driver); end
    def run_mutation_analysis(env); end
  end
end

class Mutant::Runner::Sink
  include ::Unparser::Equalizer::Methods

  def initialize(*_arg0); end

  def result(mutation_index_result); end
  def status; end
  def stop?; end

  private

  def coverage_result(mutation_result); end
  def mutation_result(mutation_index_result); end
  def previous_coverage_results(subject); end
end

Mutant::SCOPE_OPERATOR = T.let(T.unsafe(nil), String)

class Mutant::Scope
  include ::Unparser::Equalizer::Methods
end

class Mutant::Selector
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::AbstractType
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  extend ::Unparser::AbstractType::AbstractMethodDeclarations

  def call(*_arg0); end

  class << self
    def new(*args, &block); end
  end
end

class Mutant::Selector::Expression < ::Mutant::Selector
  include ::Unparser::Equalizer::Methods

  def call(subject); end
end

class Mutant::Selector::Null < ::Mutant::Selector
  include ::Unparser::Equalizer::Methods

  def call(_subject); end
end

class Mutant::Subject
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  include ::Unparser::AbstractType
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods
  include ::Enumerable

  def context; end
  def expression(*_arg0); end
  def identification(&block); end
  def match_expressions(*_arg0); end
  def mutations(&block); end
  def node; end
  def prepare; end
  def source(&block); end
  def source_line; end
  def source_lines(&block); end
  def source_path; end

  private

  def neutral_mutation; end
  def wrap_node(node); end

  class << self
    def anima; end
    def new(*args, &block); end
  end
end

class Mutant::Subject::Method < ::Mutant::Subject
  def expression(&block); end
  def match_expressions(&block); end
  def name; end

  private

  def scope; end
end

class Mutant::Subject::Method::Instance < ::Mutant::Subject::Method
  def prepare; end
end

class Mutant::Subject::Method::Instance::Memoized < ::Mutant::Subject::Method::Instance
  include ::Mutant::AST::Sexp

  def prepare; end

  private

  def wrap_node(mutant); end
end

Mutant::Subject::Method::Instance::NAME_INDEX = T.let(T.unsafe(nil), Integer)
Mutant::Subject::Method::Instance::SYMBOL = T.let(T.unsafe(nil), String)

class Mutant::Subject::Method::Metaclass < ::Mutant::Subject::Method
  include ::Mutant::AST::Sexp

  def prepare; end

  private

  def wrap_node(mutant); end
end

Mutant::Subject::Method::Metaclass::NAME_INDEX = T.let(T.unsafe(nil), Integer)
Mutant::Subject::Method::Metaclass::SYMBOL = T.let(T.unsafe(nil), String)

class Mutant::Subject::Method::Singleton < ::Mutant::Subject::Method
  def prepare; end
end

Mutant::Subject::Method::Singleton::NAME_INDEX = T.let(T.unsafe(nil), Integer)
Mutant::Subject::Method::Singleton::SYMBOL = T.let(T.unsafe(nil), String)

class Mutant::Test
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def expressions; end
  def id; end
  def identification; end

  class << self
    def anima; end
  end
end

class Mutant::Timer
  include ::Unparser::Equalizer::Methods

  def now; end
end

class Mutant::Timer::Deadline
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def initialize(*arguments); end

  def allowed_time; end
  def expired?; end
  def status; end
  def time_left; end
  def timer; end

  class << self
    def anima; end
  end
end

class Mutant::Timer::Deadline::None < ::Mutant::Timer::Deadline
  def expired?; end
  def time_left; end
end

class Mutant::Timer::Deadline::Status
  include ::Unparser::Equalizer::Methods

  def ok?; end
end

class Mutant::Transform
  include ::Unparser::AbstractType
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::AbstractType::AbstractMethodDeclarations
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def call(*_arg0); end
  def slug; end

  private

  def error(input:, cause: T.unsafe(nil), message: T.unsafe(nil)); end
  def failure(value); end
  def lift_error(error); end
  def success(value); end
  def wrap_error(error); end

  class << self
    def new(*args, &block); end
  end
end

class Mutant::Transform::Array < ::Mutant::Transform
  include ::Unparser::Equalizer::Methods

  def call(input); end

  private

  def run(input); end
end

Mutant::Transform::Array::MESSAGE = T.let(T.unsafe(nil), String)
Mutant::Transform::Array::PRIMITIVE = T.let(T.unsafe(nil), Mutant::Transform::Primitive)
Mutant::Transform::BOOLEAN = T.let(T.unsafe(nil), Mutant::Transform::Boolean)

class Mutant::Transform::Block < ::Mutant::Transform
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def block; end
  def call(input); end
  def name; end
  def slug; end

  class << self
    def anima; end
    def capture(name, &block); end
  end
end

class Mutant::Transform::Boolean < ::Mutant::Transform
  include ::Unparser::Equalizer::Methods

  def call(input); end
end

Mutant::Transform::Boolean::MESSAGE = T.let(T.unsafe(nil), String)

class Mutant::Transform::Error
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def cause; end
  def compact_message(&block); end
  def input; end
  def message; end
  def trace(&block); end
  def transform; end

  private

  def path; end

  class << self
    def anima; end
  end
end

Mutant::Transform::Error::COMPACT = T.let(T.unsafe(nil), String)

class Mutant::Transform::Exception < ::Mutant::Transform
  include ::Unparser::Equalizer::Methods

  def call(input); end
end

Mutant::Transform::FLOAT = T.let(T.unsafe(nil), Mutant::Transform::Primitive)

class Mutant::Transform::Hash < ::Mutant::Transform
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def call(input); end
  def optional; end
  def required; end

  private

  def allowed_keys(&block); end
  def coerce_key(key, input); end
  def reject_keys(input); end
  def required_keys(&block); end
  def transform(input); end
  def transform_keys(keys, input); end
  def transform_optional(input); end
  def transform_required(input); end

  class << self
    def anima; end
  end
end

Mutant::Transform::Hash::KEY_MESSAGE = T.let(T.unsafe(nil), String)

class Mutant::Transform::Hash::Key < ::Mutant::Transform
  include ::Unparser::Equalizer::Methods

  def call(input); end
  def slug(&block); end
end

Mutant::Transform::Hash::PRIMITIVE = T.let(T.unsafe(nil), Mutant::Transform::Primitive)

class Mutant::Transform::Hash::Symbolize < ::Mutant::Transform
  def call(input); end
end

Mutant::Transform::INTEGER = T.let(T.unsafe(nil), Mutant::Transform::Primitive)

class Mutant::Transform::Index < ::Mutant::Transform
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods

  def call(input); end
  def slug(&block); end

  private

  def index; end
  def transform; end

  class << self
    def anima; end
    def wrap(cause, index); end
  end
end

class Mutant::Transform::Named < ::Mutant::Transform
  include ::Unparser::Equalizer::Methods

  def call(input); end
  def slug; end
end

class Mutant::Transform::Primitive < ::Mutant::Transform
  include ::Unparser::Equalizer::Methods

  def call(input); end
  def slug(&block); end
end

Mutant::Transform::Primitive::MESSAGE = T.let(T.unsafe(nil), String)
Mutant::Transform::STRING = T.let(T.unsafe(nil), Mutant::Transform::Primitive)
Mutant::Transform::STRING_ARRAY = T.let(T.unsafe(nil), Mutant::Transform::Array)

class Mutant::Transform::Sequence < ::Mutant::Transform
  include ::Unparser::Equalizer::Methods

  def call(input); end
end

module Mutant::Util
  class << self
    def one(array); end
  end
end

class Mutant::Util::SizeError < ::IndexError; end
Mutant::VERSION = T.let(T.unsafe(nil), String)

class Mutant::Variable
  def initialize(condition_variable:, mutex:, value: T.unsafe(nil)); end

  def read; end
  def take; end
  def take_timeout(timeout); end
  def try_put(value); end
  def with; end

  private

  def empty?; end
  def full?; end
  def perform_put(value); end
  def synchronize(&block); end
  def wait(event); end
  def wait_full; end
  def wait_timeout(event, timeout); end
end

Mutant::Variable::EMPTY = T.let(T.unsafe(nil), T.untyped)

class Mutant::Variable::IVar < ::Mutant::Variable
  def populate_with; end
  def put(value); end

  private

  def perform_take; end
end

class Mutant::Variable::IVar::Error < ::RuntimeError; end

class Mutant::Variable::MVar < ::Mutant::Variable
  def initialize(condition_variable:, mutex:, value: T.unsafe(nil)); end

  def modify; end
  def put(value); end

  private

  def perform_take; end
end

class Mutant::Variable::Result
  include ::Unparser::Equalizer::Methods

  def initialize(value); end

  def timeout?; end
  def value; end
end

class Mutant::Variable::Result::Timeout < ::Mutant::Variable::Result
  class << self
    def new; end
  end
end

Mutant::Variable::Result::Timeout::INSTANCE = T.let(T.unsafe(nil), Mutant::Variable::Result::Timeout)
class Mutant::Variable::Result::Value < ::Mutant::Variable::Result; end
Mutant::Variable::TIMEOUT = T.let(T.unsafe(nil), T.untyped)

module Mutant::Variable::Timer
  class << self
    def elapsed; end

    private

    def now; end
  end
end

Mutant::WORLD = T.let(T.unsafe(nil), Mutant::World)

class Mutant::World
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Unparser::Adamantium
  include ::Unparser::Adamantium::InstanceMethods
  extend ::Unparser::Adamantium::ModuleMethods
  extend ::Unparser::Adamantium::ClassMethods

  def capture_stdout(command); end
  def condition_variable; end
  def deadline(allowed_time); end
  def gem; end
  def gem_method; end
  def inspect; end
  def io; end
  def json; end
  def kernel; end
  def load_path; end
  def marshal; end
  def mutex; end
  def object_space; end
  def open3; end
  def pathname; end
  def process; end
  def stderr; end
  def stdout; end
  def thread; end
  def timer; end

  class << self
    def anima; end
  end
end

Mutant::World::INSPECT = T.let(T.unsafe(nil), String)

class Mutant::Zombifier
  include ::Unparser::Anima::InstanceMethods
  include ::Unparser::Equalizer::Methods
  include ::Mutant::AST::Sexp

  def initialize(*_arg0); end

  private

  def call; end
  def find(logical_name); end
  def include?(logical_name); end
  def includes; end
  def kernel; end
  def load_path; end
  def namespace; end
  def namespaced_node(source_path); end
  def original; end
  def pathname; end
  def require(logical_name); end
  def require_highjack; end
  def root_require; end
  def zombify(source_path); end

  class << self
    def anima; end
    def call(*args); end
  end
end

class Mutant::Zombifier::LoadError < ::LoadError; end
