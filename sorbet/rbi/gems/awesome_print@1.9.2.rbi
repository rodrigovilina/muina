# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `awesome_print` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module AwesomeMethodArray
  def &(_other_ary); end
  def -(_other_ary); end
  def grep(pattern, &blk); end
end

module AwesomePrint
  class << self
    def console?; end
    def defaults; end
    def defaults=(_arg0); end
    def diet_rb; end
    def force_colors; end
    def force_colors!(value = T.unsafe(nil)); end
    def force_colors=(_arg0); end
    def irb!; end
    def pry!; end
    def rails_console?; end
    def usual_rb; end
    def version; end

    private

    def boolean(value); end
  end
end

module AwesomePrint::ActionView
  def ap(object, options = T.unsafe(nil)); end
  def ap_debug(object, options = T.unsafe(nil)); end
end

module AwesomePrint::ActiveSupport
  def awesome_active_support_time(object); end
  def awesome_hash_with_indifferent_access(object); end
  def cast_with_active_support(object, type); end

  class << self
    def included(base); end
  end
end

module AwesomePrint::Colorize
  def colorize(str, type); end
end

class AwesomePrint::Formatter
  include ::AwesomePrint::Colorize
  include ::AwesomePrint::ActiveSupport
  include ::AwesomePrint::OpenStruct

  def initialize(inspector); end

  def cast(object, type); end
  def cast_without_active_support(object, type); end
  def cast_without_ostruct(object, type); end
  def format(object, type = T.unsafe(nil)); end
  def inspector; end
  def options; end

  private

  def awesome_array(a); end
  def awesome_bigdecimal(n); end
  def awesome_class(c); end
  def awesome_dir(d); end
  def awesome_file(f); end
  def awesome_hash(h); end
  def awesome_method(m); end
  def awesome_object(o); end
  def awesome_rational(n); end
  def awesome_self(object, type); end
  def awesome_set(s); end
  def awesome_simple(o, type, inspector = T.unsafe(nil)); end
  def awesome_struct(s); end
  def awesome_unboundmethod(m); end
  def convert_to_hash(object); end
  def has_method_accessor?(object); end
end

AwesomePrint::Formatter::CORE_FORMATTERS = T.let(T.unsafe(nil), Array)
module AwesomePrint::Formatters; end

class AwesomePrint::Formatters::ArrayFormatter < ::AwesomePrint::Formatters::BaseFormatter
  def initialize(array, inspector); end

  def array; end
  def format; end
  def inspector; end
  def options; end

  private

  def array_prefix(iteration, width); end
  def find_method(name); end
  def generate_printable_array; end
  def generate_printable_tuples; end
  def generate_tuple(name); end
  def generic_prefix(iteration, width, padding = T.unsafe(nil)); end
  def methods_array; end
  def methods_array?; end
  def multiline_array; end
  def name_and_args_width; end
  def simple_array; end
  def tuple_prefix(iteration, width); end
  def tuple_template(item); end
  def tuples; end
  def width(items); end
end

class AwesomePrint::Formatters::BaseFormatter
  include ::AwesomePrint::Colorize

  def align(value, width); end
  def get_limit_size; end
  def indent; end
  def indentation; end
  def indented(&block); end
  def limited(data, width, is_hash = T.unsafe(nil)); end
  def method_tuple(method); end
  def outdent; end
  def should_be_limited?; end
end

AwesomePrint::Formatters::BaseFormatter::DEFAULT_LIMIT_SIZE = T.let(T.unsafe(nil), Integer)

class AwesomePrint::Formatters::ClassFormatter < ::AwesomePrint::Formatters::BaseFormatter
  def initialize(klass, inspector); end

  def format; end
  def inspector; end
  def klass; end
  def options; end
end

class AwesomePrint::Formatters::DirFormatter < ::AwesomePrint::Formatters::BaseFormatter
  def initialize(dir, inspector); end

  def dir; end
  def format; end
  def inspector; end
  def options; end
end

class AwesomePrint::Formatters::FileFormatter < ::AwesomePrint::Formatters::BaseFormatter
  def initialize(file, inspector); end

  def file; end
  def format; end
  def inspector; end
  def options; end
end

class AwesomePrint::Formatters::HashFormatter < ::AwesomePrint::Formatters::BaseFormatter
  def initialize(hash, inspector); end

  def format; end
  def hash; end
  def inspector; end
  def options; end

  private

  def empty_hash; end
  def left_width(keys); end
  def max_key_width(keys); end
  def multiline_hash; end
  def multiline_hash?; end
  def plain_single_line; end
  def pre_ruby19_syntax(key, value, width); end
  def printable_hash; end
  def printable_keys; end
  def ruby19_syntax(key, value, width); end
  def simple_hash; end
  def symbol?(key); end
end

class AwesomePrint::Formatters::MethodFormatter < ::AwesomePrint::Formatters::BaseFormatter
  def initialize(method, inspector); end

  def format; end
  def inspector; end
  def method; end
  def options; end
end

class AwesomePrint::Formatters::ObjectFormatter < ::AwesomePrint::Formatters::BaseFormatter
  def initialize(object, inspector); end

  def format; end
  def inspector; end
  def object; end
  def options; end
  def variables; end

  private

  def awesome_instance; end
  def left_aligned; end
  def valid_instance_var?(variable_name); end
end

class AwesomePrint::Formatters::SimpleFormatter < ::AwesomePrint::Formatters::BaseFormatter
  def initialize(string, type, inspector); end

  def format; end
  def inspector; end
  def options; end
  def string; end
  def type; end
end

class AwesomePrint::Formatters::StructFormatter < ::AwesomePrint::Formatters::BaseFormatter
  def initialize(struct, inspector); end

  def format; end
  def inspector; end
  def options; end
  def struct; end
  def variables; end

  private

  def awesome_instance; end
  def left_aligned; end
end

class AwesomePrint::Indentator
  def initialize(indentation); end

  def indent; end
  def indentation; end
  def shift_width; end
end

class AwesomePrint::Inspector
  def initialize(options = T.unsafe(nil)); end

  def awesome(object); end
  def colorize?; end
  def current_indentation; end
  def increase_indentation(&block); end
  def indentator; end
  def indentator=(_arg0); end
  def options; end
  def options=(_arg0); end

  private

  def dotfile_readable?(dotfile); end
  def load_dotfile; end
  def merge_custom_defaults!; end
  def merge_options!(options = T.unsafe(nil)); end
  def nested(object); end
  def printable(object); end
  def unnested(object); end
end

AwesomePrint::Inspector::AP = T.let(T.unsafe(nil), Symbol)

module AwesomePrint::Logger
  def ap(object, level = T.unsafe(nil)); end
end

module AwesomePrint::OpenStruct
  def awesome_open_struct_instance(object); end
  def cast_with_ostruct(object, type); end

  class << self
    def included(base); end
  end
end

module Kernel
  def ai(options = T.unsafe(nil)); end
  def awesome_inspect(options = T.unsafe(nil)); end
  def awesome_print(object, options = T.unsafe(nil)); end

  private

  def ap(object, options = T.unsafe(nil)); end

  class << self
    def ap(object, options = T.unsafe(nil)); end
  end
end

class String
  include ::Comparable
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::Colorize::InstanceMethods
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
  extend ::Colorize::ClassMethods

  def black(*html); end
  def blue(*html); end
  def blueish(*html); end
  def cyan(*html); end
  def cyanish(*html); end
  def gray(*html); end
  def grayish(*html); end
  def green(*html); end
  def greenish(*html); end
  def pale(*html); end
  def purple(*html); end
  def purpleish(*html); end
  def red(*html); end
  def redish(*html); end
  def white(*html); end
  def whiteish(*html); end
  def yellow(*html); end
  def yellowish(*html); end
end

String::BLANK_RE = T.let(T.unsafe(nil), Regexp)
String::ENCODED_BLANKS = T.let(T.unsafe(nil), Concurrent::Map)
